#include <iostream>
cerr输出警告和错误信息
clog输出程序运行时的一般信息
cin >> 变量名; //v vf标准输入

/*...*/注释对不能嵌套

文件结束符号：
windows: Ctrl+Z+Enter
Linux: Ctrl+D


类对象相加   P19	？？？？？？

char和signed char是不同的   char会表现为signed或unsigned一种，具体由编译器决定

算数表达式中既有无符号数又有有符号的数时，会将有符号数转化为无符号数进行计算
int i = -1;
unsigned int j = 1;
i*j => 4294967295

//死循环，无符号数永远不可能小于零
for(unsigned u = 0;  u >= 0; --u)
	std::cout << u << std::endl;
	
转义字符\
\x后面跟十六进制	eg:	\x4d(字符M)
\后面跟八进制(最多三位数字)		eg:	\115(字符M)

指定字面值类型-------------------------->P3710245
L'a', L表示宽字符，类型为wchar_t
u8"hi!", u8表示utf-8类型(仅用于字符串字面值常量1)

extern int i;	//声明i而非定义i
int j;	//声明并定义j;

引用类型的初始值必须是一个对象而不能是一个值
int ival = 1024;
int &refVal = ival;	//refVal指向ival(是ival的另一个名字)
int &refVal;	//报错    引用必须被初始化
refVal = 2;	//即ival被赋值为2

NULL是无类型的
nullptr为字面值常量是有类型的	type decltype(nullptr) nullptr_t
尽量将指针初始化为0或nullptr
eg：解决下面函数重载问题   等等
void f(void*)
{
}
void f(int)
{
}
int main()
{
    f(0); // what function will be called?
}

int *const p1	//顶层const
const int *p2	//底层const
执行拷贝操作时顶层const不受影响而底层const两个对象数据必须具有相同的底层const资格或者它们之间的数据类型可以相互转换

const int *p = nullptr;	//p是一个指向整型常量的指针
constexpr int *q = nullptr;	//q是一个指向整数的常量指针

using //别名声明

auto类型
auto让编译器通过初始值来推算变量的类型
atuo i = a + b;	//i初始化为a和b相加的结果
auto会忽略掉顶层const而保留底层const

decltype类型
它的作用是选择并返回操作数的数据类型
decltype(f()) sum = x;	//sum的类型就是函数f()的返回类型
decltype会保留顶层const类型
decltype的表达式如果是加上括号的变量，结果将是引用
decltype((i)) d;	//error  d是int&类型 必须初始化
decltype((variable))的结果永远是引用

string类型初始化
string a(5, 'c');	//a的内容是ccccc
string可以直接使用"+"连接字符串(必须确保+号两边的运算对象至少有一个是string)
使用cin输入初始化string对象时会自动忽略开头的空白(空格符，换行符，制表符等)并从第一个真正的字符开始读起，直到遇见下一处空白为止
getline则可以读取一整行直到换行符     string line;  getline(cin, line);

string类型可以使用size方法判断其对象大小
eg:
	string s1 = "abcdefg";
	s1.size()	//其返回值是size_type类型 是无符号的
//所以 s1.size() < n; //如果n是一个负的int类型 则表达式永远为true
	
vector标准库类型
vector<int> ivec(10, -1);	//10个int类型元素，每个都初始化为-1
vector<string> v1{"a", "an", "the"};	//列表初始化，3个string类型元素
vector<int> i = 10;	//error，必须指定向量大小eg：vector<int> i = (10);
vector<string> v6("hi");	//error 不能使用字符串字面值构建vector对象
vector<string> v7{10};	//v7有10个默认初始化的元素
vector<string> v5{"hi"};
只有v5是列表初始化，v7不是列表初始化，无法用int值初始化string对象

vector成员函数push_back
vector<int> v2;
for(int i = 0; i != 100; ++1)
	v2.push_back(i);	//依次把整数值放入v2尾部
tip：
	如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
	vector对象的下标运算符可以用于访问已存在的元素而不能够用于添加元素(添加元素请使用push_back)
	
vector支持下标运算符，string支持迭代器
  1 #include <iostream>
  2 #include <string>
  3 #include <cstring>
  4 #include <vector>
  5 using namespace std;
  6 int main()
  7 {
  8     string a = "this is a string";
  9     cout << *a.begin() << endl;       //t
 10 
 11     vector<int> vecint;
 12     for(int i = 0; i < 10; i++)
 13         vecint.push_back(i);
 14     cout << vecint[0] << endl;      //0
 15     return 0;
 16 }

iterator和const_iterator用来表示迭代器的类型
vector<int>:: iterator it;	//it能读写vector<int>的元素
string:: iterator it2;	//it2能读写string对象中的字符
vector<int>:: iterator it3;	//it3只能读元素不能够写元素

vector<int> v;
const vector<int> cv;
auto it1 = v.begin();	//it1的类型为vector<int>:: iterator
auto it2 = cv.begin();	//it2的类型为vector<int>:: const_iterator
C++11标准
引入cbegin()和cend();
auto it3 = v.cbegin();	//it3的类型为vector<int>:: const_iterator
无论vector对象(string对象)是否是const类型其返回值都是const_iterator类型

不能在范围for循环中向vector对象添加元素
任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效
//如果容器是vector或string，
//如果存储空间被重新分配，迭代器、指针、引用都会失效;
//如果存储空间的未重新分配则在插入位置之前的迭代器、指针、引用都有效而插入位置之后的元素的迭代器、指针、引用都会失效)
详细：P315

vector和string迭代器 能够使用关系运算符进行比较，但两个迭代器必须合法且指向的是同一个容器

size_t、ptrdiff_t定义在cstddef头文件中
size_t类型，size_t类型是一种机器相关的无符号类型，它被设计的足够大以便能够表示内存中任意对象的大小
ptrdiff_t类型，(eg: 两个指针相减的结果类型)，是一种带符号的类型

int a1[] = {0, 1, 2, 3, 4, 5};
int a2[] = a1;	//error 不能使用一个数组来初始化另一个数组
a2 = a1;	//error 不能将一个数组直接赋值另一个数组
auto a3 = a1;	//a3被初始化为一个指针，指向a1首部

C++11标准
int array[] = {0, 1, 2, 3, 4, 5, 6};
int *beg = begin(array);	//指向数组首元素
int *end = end(array);	//指向数组尾元素的下一元素位置

虽然标准库类型string和vector也支持下标运算但是标准库类型限定使用的下标类型必须是无符号类型(eg: size_type)
如果它们的下标设置成了有符号的类型，则会自动转成string::size_type无符号类型(所以当下标为负值的时候很容易出错)

char a[] = {'g', 'a', 'o'};		//不以空字符结束
cout << strlen(a) << endl;	//长度未知，strlen运行到'\0'才会停下来

string可以直接使用<、>等关系运算符比较字符串而C风格必须借助字符串操作函数

cin >> v1 >> v2;	//先读入v1，再读入v2
求值顺序：
int i = f1() * f2();	//无法确定是f1先调用还是f2先调用
<<运算符也没有规定何时以及如何对运算对象求值
eg:
	int i = 1;
	cout　<< i << " " << ++i << endl;	//可能先求++i的值再求i，也有可能先求i再求++i  此表达式的结果不可预知
有四种运算符规定运算对象的求值顺序
(自左向右求值)
逻辑与&&
逻辑或||
条件运算符?:
逗号运算符,

m%(-n) => m%n
(-m)%n => -(m%n)
-21%-8 => -5

强制类型转换(显示类型转换)
1、static_cast:
	只要不包含底层const，都可以使用(const int ci = 42; => 顶层  	const int *pi = &ci; => 底层)
	int i;
	double slope = static_cast<double>(i);
2、dynamic_cast:
3、const_cast:
	只能改变运算对象底层const，不能用const_cast改变表达式的类型
	const char *cp
	static_cast<string>(cp);	//true: 字符串字面值转换成string类型
	const_cast<string>(cp);		//false: const_cast只能改变常量属性
4、reinterpret_cast:
	为运算对象的位模式提供较低层次上的重新解释
	
;	//空语句
ival = v1 + v2;;	//true 第二个;表示一个空语句

for(;;) for循环支持定义多个对象，但是只支持一条声明语句

//范围for语句
for(declaration : expression)
	statement
范围for语句中预存了end值，所以在范围for语句中使用删除、插入操作都有可能使end函数的值无效   P169

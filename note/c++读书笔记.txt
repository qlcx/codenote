#include <iostream>
cerr输出警告和错误信息
clog输出程序运行时的一般信息
cin >> 变量名; //v vf标准输入

/*...*/注释对不能嵌套

文件结束符号：
windows: Ctrl+Z+Enter
Linux: Ctrl+D


类对象相加   P19	？？？？？？

char和signed char是不同的   char会表现为signed或unsigned一种，具体由编译器决定

算数表达式中既有无符号数又有有符号的数时，会将有符号数转化为无符号数进行计算
int i = -1;
unsigned int j = 1;
i*j => 4294967295

//死循环，无符号数永远不可能小于零
for(unsigned u = 0;  u >= 0; --u)
	std::cout << u << std::endl;
	
转义字符\
\x后面跟十六进制	eg:	\x4d(字符M)
\后面跟八进制(最多三位数字)		eg:	\115(字符M)

指定字面值类型-------------------------->P3710245
L'a', L表示宽字符，类型为wchar_t
u8"hi!", u8表示utf-8类型(仅用于字符串字面值常量1)

extern int i;	//声明i而非定义i
int j;	//声明并定义j;

引用类型的初始值必须是一个对象而不能是一个值
int ival = 1024;
int &refVal = ival;	//refVal指向ival(是ival的另一个名字)
int &refVal;	//报错    引用必须被初始化
refVal = 2;	//即ival被赋值为2

NULL是无类型的
nullptr为字面值常量是有类型的	type decltype(nullptr) nullptr_t
尽量将指针初始化为0或nullptr
eg：解决下面函数重载问题   等等
void f(void*)
{
}
void f(int)
{
}
int main()
{
    f(0); // what function will be called?
}

int *const p1	//顶层const
const int *p2	//底层const
执行拷贝操作时顶层const不受影响而底层const两个对象数据必须具有相同的底层const资格或者它们之间的数据类型可以相互转换

const int *p = nullptr;	//p是一个指向整型常量的指针
constexpr int *q = nullptr;	//q是一个指向整数的常量指针

using //别名声明

auto类型
auto让编译器通过初始值来推算变量的类型
atuo i = a + b;	//i初始化为a和b相加的结果
auto会忽略掉顶层const而保留底层const

decltype类型
它的作用是选择并返回操作数的数据类型
decltype(f()) sum = x;	//sum的类型就是函数f()的返回类型
decltype会保留顶层const类型
decltype的表达式如果是加上括号的变量，结果将是引用
decltype((i)) d;	//error  d是int&类型 必须初始化
decltype((variable))的结果永远是引用

string类型初始化
string a(5, 'c');	//a的内容是ccccc
string可以直接使用"+"连接字符串(必须确保+号两边的运算对象至少有一个是string)
使用cin输入初始化string对象时会自动忽略开头的空白(空格符，换行符，制表符等)并从第一个真正的字符开始读起，直到遇见下一处空白为止
getline则可以读取一整行直到换行符     string line;  getline(cin, line);

string类型可以使用size方法判断其对象大小
eg:
	string s1 = "abcdefg";
	s1.size()	//其返回值是size_type类型 是无符号的
//所以 s1.size() < n; //如果n是一个负的int类型 则表达式永远为true
	
vector标准库类型
vector<int> ivec(10, -1);	//10个int类型元素，每个都初始化为-1
vector<string> v1{"a", "an", "the"};	//列表初始化，3个string类型元素
vector<int> i = 10;	//error，必须指定向量大小eg：vector<int> i = (10);
vector<string> v6("hi");	//error 不能使用字符串字面值构建vector对象
vector<string> v7{10};	//v7有10个默认初始化的元素
vector<string> v5{"hi"};
只有v5是列表初始化，v7不是列表初始化，无法用int值初始化string对象

vector成员函数push_back
vector<int> v2;
for(int i = 0; i != 100; ++1)
	v2.push_back(i);	//依次把整数值放入v2尾部
tip：
	如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
	vector对象的下标运算符可以用于访问已存在的元素而不能够用于添加元素(添加元素请使用push_back)
	
vector支持下标运算符，string支持迭代器
  1 #include <iostream>
  2 #include <string>
  3 #include <cstring>
  4 #include <vector>
  5 using namespace std;
  6 int main()
  7 {
  8     string a = "this is a string";
  9     cout << *a.begin() << endl;       //t
 10 
 11     vector<int> vecint;
 12     for(int i = 0; i < 10; i++)
 13         vecint.push_back(i);
 14     cout << vecint[0] << endl;      //0
 15     return 0;
 16 }

iterator和const_iterator用来表示迭代器的类型
vector<int>:: iterator it;	//it能读写vector<int>的元素
string:: iterator it2;	//it2能读写string对象中的字符
vector<int>:: iterator it3;	//it3只能读元素不能够写元素

vector<int> v;
const vector<int> cv;
auto it1 = v.begin();	//it1的类型为vector<int>:: iterator
auto it2 = cv.begin();	//it2的类型为vector<int>:: const_iterator
C++11标准
引入cbegin()和cend();
auto it3 = v.cbegin();	//it3的类型为vector<int>:: const_iterator
无论vector对象(string对象)是否是const类型其返回值都是const_iterator类型

不能在范围for循环中向vector对象添加元素
任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效
//如果容器是vector或string，
//如果存储空间被重新分配，迭代器、指针、引用都会失效;
//如果存储空间的未重新分配则在插入位置之前的迭代器、指针、引用都有效而插入位置之后的元素的迭代器、指针、引用都会失效)
//对于vector和string来说当我们删除元素的时候尾后迭代器总会失效
详细：P315

vector和string迭代器 能够使用关系运算符进行比较，但两个迭代器必须合法且指向的是同一个容器

size_t、ptrdiff_t定义在cstddef头文件中
size_t类型，size_t类型是一种机器相关的无符号类型，它被设计的足够大以便能够表示内存中任意对象的大小
ptrdiff_t类型，(eg: 两个指针相减的结果类型)，是一种带符号的类型

int a1[] = {0, 1, 2, 3, 4, 5};
int a2[] = a1;	//error 不能使用一个数组来初始化另一个数组
a2 = a1;	//error 不能将一个数组直接赋值另一个数组
auto a3 = a1;	//a3被初始化为一个指针，指向a1首部

C++11标准
int array[] = {0, 1, 2, 3, 4, 5, 6};
int *beg = begin(array);	//指向数组首元素
int *end = end(array);	//指向数组尾元素的下一元素位置

虽然标准库类型string和vector也支持下标运算但是标准库类型限定使用的下标类型必须是无符号类型(eg: size_type)
如果它们的下标设置成了有符号的类型，则会自动转成string::size_type无符号类型(所以当下标为负值的时候很容易出错)

char a[] = {'g', 'a', 'o'};		//不以空字符结束
cout << strlen(a) << endl;	//长度未知，strlen运行到'\0'才会停下来

string可以直接使用<、>等关系运算符比较字符串而C风格必须借助字符串操作函数

cin >> v1 >> v2;	//先读入v1，再读入v2
求值顺序：
int i = f1() * f2();	//无法确定是f1先调用还是f2先调用
<<运算符也没有规定何时以及如何对运算对象求值
eg:
	int i = 1;
	cout　<< i << " " << ++i << endl;	//可能先求++i的值再求i，也有可能先求i再求++i  此表达式的结果不可预知
有四种运算符规定运算对象的求值顺序
(自左向右求值)
逻辑与&&
逻辑或||
条件运算符?:
逗号运算符,

m%(-n) => m%n
(-m)%n => -(m%n)
-21%-8 => -5

强制类型转换(显示类型转换)
1、static_cast:
	只要不包含底层const，都可以使用(const int ci = 42; => 顶层  	const int *pi = &ci; => 底层)
	int i;
	double slope = static_cast<double>(i);
2、dynamic_cast:
3、const_cast:
	只能改变运算对象底层const，不能用const_cast改变表达式的类型
	const char *cp
	static_cast<string>(cp);	//true: 字符串字面值转换成string类型
	const_cast<string>(cp);		//false: const_cast只能改变常量属性
4、reinterpret_cast:
	为运算对象的位模式提供较低层次上的重新解释
	
;	//空语句
ival = v1 + v2;;	//true 第二个;表示一个空语句

for(;;) for循环支持定义多个对象，但是只支持一条声明语句

//范围for语句
for(declaration : expression)
	statement
范围for语句中预存了end值，所以在范围for语句中使用删除、插入操作都有可能使end函数的值无效   P169

使用引用避免拷贝
eg：比较两个string字符串，但是string对象很长的话
bool isShorter(const string &s1, const string &s2)
{
	return s1.size() < s2.size();
}
并且如果函数无须改变引用形参的值，最好将其声明为常量引用;
eg：string::size_type find_char(string &s, char c, string::size_type &occurs);
如果find_char("Hello World", 'o', ctr);调用的话编译会发生错误，因为string &s只能接受非常量string对象，所以应该设为const string &s
9，哦，，哦，\，}
实参初始化形参时会忽略掉顶层const
c++中可以定义若干具有相同名字的函数，但是不同形参列表应该有明显的区别
void fcn(const int i)
void fcn(int i)
//error 重复定义，因为顶层const被忽略掉了

int main(int argc, char *argv[])
使用argv的时候注意argv[0]保存的是程序的名字，用户的输入从argv[1]开始保存

initializer_list类型(保存在同名头文件中)
使用与vector一样，不一样的是initializer_list对象中的元素永远是常量值
eg：
	//expected和actual是string对象
	if(expected != actual)
		error_msg("functionX", expected, actual);
	else
		error_msg("functionX", "okay");
//error_msg函数形参个数不同
void error_msg(ErrCode e, initializer_list<string> i1) {}	//只要类型相同就可以使用initializer_list模板  P199

string retvlaue()
{
	return "Empty";	//error   字面值常量转换成局部临时的string对象，函数结束时存储空间会释放
}

vector<string> process()
{
	//......
	if(...)
		return {};	//返回一个空vector对象
	else
		return {"functionX", "string"};	//返回列表初始化的vector对象
}

返回数组指针
int (*func(int i))[10];		//函数func接受一个int类型实参，返回一个指向含有10个整数的数组的指针
可以使用尾置返回类型简化它
auto func(int i) -> int(*)[10];

重载：
二义性调用：有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时将发生错误

string read()
void print(const string &);
void print(double);
void fooBar(int ival)
{
	bool read = false;	//新作用域：隐藏了外层的read
	string s = read();	//error: read是一个布尔值，而不是函数
	void print(int);	//声明函数，隐藏了之前的print
	print("Value: ");	//error: print(const string &)被隐藏
	print(3.14);		//true: 调用print(int), print(double)被隐藏掉了
}

内联函数inline
在被调用函数的返回类型前面加上关键字inline
inline const string & shorterString(const string &s1, const string &s2)
{
	return s1.size() <= s2.size() ? s1 : s2;
}

cout << shorterString(s1, s2) << endl;
在编译过程中会展开成
cout << (s1.size() <= s2.size() ? s1 : s2) << endl;
的形式从而省去了调用函数产生的开销

//常量表达式
constexpr size_t scale(size_t cnt) {return cnt;}
当scale的实参是常量时，它返回值也是一个常量表达式；反之则不然

assert(exp);	//exp为一个表达式
NDEBUG		//关闭调试状态
CC -D NDEBUG main.c 或者在main.c一开始写#define NDEBUG

//用于调试的局部静态变量
__FILE__	存放文件名的字符串字面值
__LINE__	存放当前行号的整形字面值
__TIME__	存放文件编译时间的字符串字面值
__DATE__	存放文件编译日期的字符串字面值

string screen(int ht = 24, int wid = 80, char backgrnd = ' ');	//默认实参
sring window;
window = screen();	//等价于screen(24, 80, ' ');
window = screen(66, 256, '#');	//screen(66, 256, '#');

//二义性
void f(int, int);
void f(double, double = 3.14);
f(4, 5.6);	//error，两函数同时满足且从整体上来说无法判断孰优孰劣，此调用具有二义性错误

含有多个可行函数时需要满足：
1、该函数每个实参的匹配都不劣于其他可行函数需要的匹配
2、至少有一个实参的匹配优于其他可行函数提供的匹配
如果判断下来没有一个函数脱颖而出则为二义性错误

void manip(long);
void manip(float);
manip(3.14);	//二义性错误，3.14为double类型
//转换等级划分P219

重载函数指针
void ff(int*)
void ff(unsigned int);

void (*pf1)(unsigned int) = ff;	//pf1指向ff(unsigned)
指针类型必须与重载函数中的某一个精确匹配(返回值类型，形参列表)

构造函数eg:
struct Sales_data {
	//构造函数
	Sales_data() = default;		//意义：既需要其他形式的构造函数，也需要默认的构造函数
	Sales_data(const std::string &s) : bookNo(s) {}
	
	std::string bookNo;
}

定义在类内部的成员函数会自动inline

可变数据成员
mutable
eg:
	class Screen {
	public:
		void some_member() const;
	private:
		mutable size_t access_ctr = 0;	//类内初始化c++11
	};
	void Screen::some_member() const	//虽然some_member是const成员函数，但是access_ctr还是可变的
	{
		++access_ctr;	//如果access_ctr没有设置mutable则它是只读的
	}
	
即使两个类的成员列表完全一致，它们也是不同的类型P249

//P250
//前向声明(可以定义指向这种类型的指针或引用，也可以声明(但不能定义)以不完全类型作为参数或者返回类型的函数)
class Y;
class x {
	Y* y = nullptr;	//定义指向Y类型的指针
};
class Y {
	X x;
};

一个类的成员函数作为另一个类的友元		//该成员函数必须在另一个类之前声明！！！		P251
struct X {
	friend void f() {/*友元函数可以定义在类的内部*/};	//即使在类中被定义，只要还没声明那么在类中该函数还是不可见的
	x() {f();}	//error： f还没有被声明
	void g();
}
void f();	//声明f函数
void X::g {return f();}	//true, f()已经被声明

编译器处理完类中的全部声明后才会处理成员函数的定义

typedef double Money;
string bal;
class Account {
public:
	Money balance() {return bal;}	//编译balance的声明时，会先找到Money的声明，balance函数体在整个类可见后才处理，所以返回的是bal成员对象而不是string对象
private:
	Money bal;
	//....
}

构造函数的初始化和赋值
class ConstRef {
public:
	ConstRef (int ii);
private:
	int i;
	const int ci;
	int &ri;
}
//赋值操作
ConstRef::ConstRef(int ii)
{
	i = ii;		//true;
	ci = ii;	//error	const不能赋值
	ri = i;		//error ri没被初始化
}
//列表初始化(显示的初始化引用和const成员)
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) {}

//委托构造函数
class Sales_data {
public:
	//非委托构造函数
	Sale_data(string a, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt *price) {}
	//以下构造函数全部委托第一条构造函数
	Sales_data() : Sales_data("", 0, 0);
	Sales_data(string s): Sales_data(s, 0, 0);
	
	//....
}

隐式的类类型转换
注意：编译器只会自动执行一步类型转换
combine(const Sale_data &);
combine("9-9999-9999");	//error, 需要把9-9999-9999转换成string类型才能再转换成Sale_data类型需要两步
//true
combine(string("9-9999-9999"));	//隐式转换
combine(Sale_data("9-9999-9999"));	//显示转换

//抑制构造函数的隐式转换
在构造函数前加上explicit关键字(explicit Sale_data(const std::string &s):bookNo(s) {})，之前两种用法都不能通过编译(除了显示转换的方式)。
注意：
1、explicit只对一个实参的构造函数有效，并且需要多个实参的构造函数也不能用于执行隐式类型转换
2、只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应该重复
3、explicit修饰的构造函数只能使用直接初始化的方式
Sale_data item1("hiya");	//直接初始化	true
Sale_data item2 = "hiya";	//拷贝初始化	error

静态成员函数
1、不能包含this指针
2、静态成员函数不能声明成const
3、不能在static函数体内使用this指针
4、静态数据成员一般在类内部声明在类的外部定义和初始化(由于不属于类的任何一个对象，所以它们不是由类的构造函数初始化的)
5、一般静态数据成员不应该在类内部初始化，除了: (在Account类内部)static constexpr int period = 30;	//period是常量表达式   P270
6、即使一个常量静态数据成员在类内部初始化了，通常情况下也应该在类的外部定义(不带初始值)一下该成员
constexpr int Account::period;	//一个不带初始值的静态成员的外部定义

IO库
iostream：用于读写的流基本类型(istream, ostream, iostream)
fstream：读写命名文件类型(ifstream, ofstream, fstream)
sstream: 读写内存string对象类型(istringstream, ostringstream, stringstream)
//不能拷贝或对IO对象赋值 ofstream out1, out2;	out1 = out2;	//error

cout << unitbuf;	//所有输出操作后都会立即刷新缓冲区
cout << nounitbuf;	//回到正常的缓冲方式
!!如果程序崩溃输出缓冲区不会被刷新

文件输入输出
fstream fstrm;	//创建一个未绑定的文件流
fstream fstrm(s);	//创建一个fstream，并打开名为s的文件
fstream fstrm(s, mode);	//创建一个fstream，并按照mode打开文件
fstrm.open(s);	//打开名为s的文件，并将文件与fstrm绑定
fstrm.close();	//关闭文件
fstrm.is_open();	//返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭


文件mode：
in	//读
out	//写		会丢失已有数据(可以同时指定app或in模式保证数据不丢失)
app	//每次写操作前均定位到文件末尾
ate	//打开文件后立即定位到文件末尾
trunc	//截断文件
binary	//以二进制的方式进行IO
open调用默认的模式是out模式(out模式意味着同时使用trunc模式)
限制：P286

istringstream和ostringstream对整行文本的输出输入比较有效果

iostream处理控制台IO
fstream处理命名文件IO
stringstream完成内存string的IO
fstream和stringstream都是继承自iostream

顺序容器
vector: 可变大小数组
deque: 双端对列
list: 双向链表
forward_list: 单向链表	不支持--操作 支持empty和max_size操作但不支持size操作
array: 固定大小数组
string: 与vector类似，但专门用于保存字符
最好使用vector，程序要求随机访问元素，则使用vector或deque，程序要求在容器的中间插入或删除元素，则使用list或forward_list

如果顺序容器中的类型没有默认构造函数就需要提供一个初始值
//noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);	//true   数目：10，初始值：init
vector<noDefault> v2(10);	//false

使用迭代器拷贝不要求容器类型和元素类型相同(前提是元素类型之间可以转换)，直接拷贝就要保证两个容器的类型及其元素类型必须匹配
list<string> authors = {"milton", "shakespeara", "austen"};
it为authors中的一个元素
deque<string> authList(authors.begin(), it);	//拷贝元素直到但不包括it指向的元素

定义一个array时，除了要指定元素类型还需要指定容器大小
array<int, 42> ia1;	//true
array<int> ia2;	//false

内置数组类型不能进行拷贝或对象赋值操作但是array类型可以
int dits[3] = {0, 1, 2};
int cpy[3] = dits;	//false
array<int, 3> digits = {0, 1, 2};
array<int, 3> copy = digits;	//true

顺序容器的赋值
  6 int main() {
  7     vector<int> i1 = {0, 1, 2};
  8     vector<int> i2 = {3, 4};
  9 
 10     i1 = i2;
 11 
 12     for(auto i : i1) cout << i << " ";  //3 4
 13     cout << endl;
 14     return 0;
 15 }
 i1 = i2;	//将i1中的内容替换为i2中的内容，包括其大小
 i1 = {0, 1, 3};	//对i1进行列表赋值
 array类型不支持assign和列表赋值

 seq.assign(b, e);	//将seq中的元素替换为迭代器b和e所表示的范围中的元素，迭代器b和e不能指向seq中的元素
 seq.assign(i1);	//将seq中的元素替换为初始化列表i1中的元素
 seq.assign(n, t);	//将seq中的元素替换为n个值为t的元素
 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap和assign则不会(array和string除外)
 assign: 成员类型相同容器类型可以不同的赋值方法
 
 vector<string> svec1(10);
 vector<string> svec2(24);
 swap(svec1, svec2);	//svec1将有24个string元素，svec2将有10个string元素
 swap不会使迭代器失效，iter在交换前指向svec1[3]，交换后则指向svec2[3]
 
 关系运算符(== >= ...)左右的元素类型和容器类型必须相同
 
 
//顺序容器添加元素操作	p305
 forward_list不支持push_back和emplace_back
 string和vector不支持push_front和emplace_front
 
 //在c的尾部创建一个值为t或由args创建的元素，返回void
 c.push_back(t);
 c.emplace_back(args);
 push_front、emplace_front操作类似
 
 insert	//插入元素
 insert第一个参数为迭代器
 //在迭代器p指向的元素前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器
 c.insert(p,t);
 c.emplace(p,args);
 
 c.insert(p,n,t);	//在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，n = 0则返回p
 c.insert(p,b,e);	//将迭代器b和e所表示的范围中的元素，插入到p指向的元素之前，b和e不能指向c中的元素
 c.insert(p,i1);	//i1是元素值列表，将这些定制插入到迭代器p指向的元素之前
 
 对vector、string和deque插入元素会使指向容器的迭代器、引用和指针失效
 
 //iter指向c中的一个元素，其中保存了Sales_data元素
 c.emplace_back();	//使用Sales_data的默认构造函数
 c.empalec(iter, "999-999999999");	//使用Sale_data(string)
 //使用Sales_data的接收一个ISBN、一个count和一个price的构造函数
 c.emplace_front("999-987639324", 25, 15.99);
 
 //访问顺序容器中的元素
 at和下标操作只适用于string、vector、deque和array
 back不适用forward_list
 c.back()	//返回c中尾元素的引用，若c为空，函数行为未定义
 c.front()	//返回c中首元素的引用，若c为空，函数行为未定义
 c[n]		//下标访问，越界，函数行为未定义
 c.at(n)	//下标访问，越界，抛出out_of_range异常
 
 //删除元素
 forward_list不支持pop_back; vector和string不支持pop_front
 c.pop_back()	//删除c中的尾元素
 c.pop_front()	//删除c中的首元素
 c.erase(p);	//删除迭代器p所指定的元素，返回一个指向被删除元素之后元素的迭代器
 c.erase(b, e);	//删除迭代器b和e指定范围内的元素[b, e)，返回一个指向最后一个被删元素之后的迭代器
 c.clear();		//删除c中的所有元素
 删除deque中除首尾位置的任何元素都会使所有迭代器、引用和指针失效(如果在首尾位置添加元素迭代器会失效//删除(删除尾元素会使尾后迭代器失效，其他不受影响))。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效
 
 forward_list中插入删除操作
 insert_after、emplace_after、erase_after和before_begin(返回一个首前迭代器)
 before_begin允许我们在链表首元素之前并不存在的元素之后添加或删除元素
 在处理forward_list中添加或删除元素时需要关注两个迭代器：一个指向待处理元素，一个指向其前驱(before_begin)	P313
 
 改变容器大小resize(array不支持)
 //当前大小大于所要求的的大小，容器后部的元素会被删除，如果当前大小小于所要求的大小，会将新元素加到容器后面
 c.resize(n);	//调整c的大小为n个元素，若需要添加元素，对新元素默认初始化
 c.resize(n, t);	//调整c的大小为n个元素，任何新添加的元素都初始化为t
 如果resize为缩小容器的操作，则指向被删除元素的迭代器，指针和引用都会失效
 
 哪些操作会使容器的迭代器、引用和指针失效？P315
 无论是添加或删除元素list和forward_list的(对于删除操作来说：指向其他位置的)迭代器、引用和指针都不会失效
 当添加/删除vector或string的元素，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总会失效，所以添加或删除元素时end必须一直更新
 
 管理容量的成员函数
 capacity:告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素(size指它已经保存的元素数目)
 reserve:操作允许我们通知容器它应该准备保存多少个元素
 c.shrink_to_fit()	//请将capacity()减少为与size相同大小
 c.capacity()	//不重新分配内存空间的话，c可以保存多少元素
 c.reserve(n)	//分配至少能容纳n个元素的空间
 //shrink_to_fit只适用于vector、string和deque
 //capacity和reserve只适用于vector和string
 //reserve并不改变容器中元素的数量，它仅影响vector预先分配都打的内存空间  具体见P318

 //n、len2和pos2都是无符号值
 string s(cp, n);		//s是cp指向的数组中前n个字符的考别
 string s(s2, pos2);	//s是string s2从下标pos2开始的字符的拷贝，pos2越界则构造函数的行为未定义
 string s(s2, pos2, len2);	//s是string s2从下标pos2开始len2字符的拷贝，pos2越界则构造函数的行为未定义，不管len2值为多少至多拷贝s2.size() - pos2个字符
 
 s.substr(pos);			//从string的pos位置开始拷贝，超过则抛出out_of_range
 s.substr(pos, n);		//从string和pos位置开始拷贝n个字符， pos默认值为0，n默认值为s.size()-pos
 
 s.append(args);	//将args追加到s，返回一个指向s的引用
 s.replace(range, args);	//删除s中范围range的字符，替换为args指定的字符，返回一个指向s的引用
 string s("c++ primer"), s2 = s;
 s2.append(" 4th Ed ");	//s2为c++ primer 4th Ed
 s2.replace(11, 3, "5th");	//s2为c++ primer 5th Ed
 s2.replace(11, 3, "fifth");	//s2为c++ primer fifth Ed
 //assign总是替换string中的所有内容，append总是将新字符追加到string末尾
 
 string搜索操作
 //string搜索函数返回string::size_type值，所以使用auto类型保存返回值比较明智
 
 args、s为string
 s.find(args)	//查找s中args第一次出现的位置	//否则返回npos
 s.rfind(args)	//查找s中args最后一次出现的位置
 s.find_first_of(args)	//在s中查找args中任何一个字符第一次出现的位置
 s.find_last_of(args)	//在s中查找args中任何一个字符最后一次出现的位置
 s.find_first_not_of(args)	//在s中查找第一个不在args中的字符
 s.find_last_not_og(args)	//在s中查找最后一个不在args中的字符
 args为以下形式
 c, pos:	从s中位置pos开始查找字符c，pos默认0
 s2, pos:	从s中位置pos开始查找字符串s2，pos默认0
 cp, pos:	从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串pos默认0
 cp, pos, n:从s中位置pos开始查找指针cp指向的数组的前n个字符，pos和n无默认值
 
 string的compare函数P327
 
 数值转换
 to_string(val);	//返回数值val的string表示
 stoi(s,p,b)/stol/stoul/stoll/stoull;	//b表示转换所用的基数默认为10，p是size_t指针，用来保存s中的第一个非数值的字符，默认为0，即函数不保存下标
 stof(s,p)/stod/stold;	//p作用同上
 //如果string不能转换为一个数值则抛出invalid_argument错误
 //如果转换得到的数值无法用任何类型来表示则抛出out_of_range异常
 
 string s2 = "pi = 3.14";
 //转换s2中以数字开始的第一个子串，结果是d = 3.14;
 d = stod(s2.substr(s2.find_first_of("+-.0123456789")));
 
 适配器操作stack、queue和priority_queue	P329
 栈适配器；stack
 队列适配器：queue、priority_queue
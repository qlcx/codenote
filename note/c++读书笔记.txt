#include <iostream>
cerr输出警告和错误信息
clog输出程序运行时的一般信息
cin >> 变量名; //v vf标准输入

/*...*/注释对不能嵌套

文件结束符号：
windows: Ctrl+Z+Enter
Linux: Ctrl+D


类对象相加   P19	？？？？？？

char和signed char是不同的   char会表现为signed或unsigned一种，具体由编译器决定

算数表达式中既有无符号数又有有符号的数时，会将有符号数转化为无符号数进行计算
int i = -1;
unsigned int j = 1;
i*j => 4294967295

//死循环，无符号数永远不可能小于零
for(unsigned u = 0;  u >= 0; --u)
	std::cout << u << std::endl;
	
转义字符\
\x后面跟十六进制	eg:	\x4d(字符M)
\后面跟八进制(最多三位数字)		eg:	\115(字符M)

指定字面值类型-------------------------->P3710245
L'a', L表示宽字符，类型为wchar_t
u8"hi!", u8表示utf-8类型(仅用于字符串字面值常量1)

extern int i;	//声明i而非定义i
int j;	//声明并定义j;

引用类型的初始值必须是一个对象而不能是一个值
int ival = 1024;
int &refVal = ival;	//refVal指向ival(是ival的另一个名字)
int &refVal;	//报错    引用必须被初始化
refVal = 2;	//即ival被赋值为2

NULL是无类型的
nullptr为字面值常量是有类型的	type decltype(nullptr) nullptr_t
尽量将指针初始化为0或nullptr
eg：解决下面函数重载问题   等等
void f(void*)
{
}
void f(int)
{
}
int main()
{
    f(0); // what function will be called?
}

int *const p1	//顶层const
const int *p2	//底层const
执行拷贝操作时顶层const不受影响而底层const两个对象数据必须具有相同的底层const资格或者它们之间的数据类型可以相互转换

const int *p = nullptr;	//p是一个指向整型常量的指针
constexpr int *q = nullptr;	//q是一个指向整数的常量指针

using //别名声明

auto类型
auto让编译器通过初始值来推算变量的类型
atuo i = a + b;	//i初始化为a和b相加的结果
auto会忽略掉顶层const而保留底层const

decltype类型
它的作用是选择并返回操作数的数据类型
decltype(f()) sum = x;	//sum的类型就是函数f()的返回类型
decltype会保留顶层const类型
decltype的表达式如果是加上括号的变量，结果将是引用
decltype((i)) d;	//error  d是int&类型 必须初始化
decltype((variable))的结果永远是引用

string类型初始化
string a(5, 'c');	//a的内容是ccccc
string可以直接使用"+"连接字符串(必须确保+号两边的运算对象至少有一个是string)
使用cin输入初始化string对象时会自动忽略开头的空白(空格符，换行符，制表符等)并从第一个真正的字符开始读起，直到遇见下一处空白为止
getline则可以读取一整行直到换行符     string line;  getline(cin, line);

string类型可以使用size方法判断其对象大小
eg:
	string s1 = "abcdefg";
	s1.size()	//其返回值是size_type类型 是无符号的
//所以 s1.size() < n; //如果n是一个负的int类型 则表达式永远为true
	
vector标准库类型
vector<int> ivec(10, -1);	//10个int类型元素，每个都初始化为-1
vector<string> v1{"a", "an", "the"};	//列表初始化，3个string类型元素
vector<int> i = 10;	//error，必须指定向量大小eg：vector<int> i = (10);
vector<string> v6("hi");	//error 不能使用字符串字面值构建vector对象
vector<string> v7{10};	//v7有10个默认初始化的元素
vector<string> v5{"hi"};
只有v5是列表初始化，v7不是列表初始化，无法用int值初始化string对象

vector成员函数push_back
vector<int> v2;
for(int i = 0; i != 100; ++1)
	v2.push_back(i);	//依次把整数值放入v2尾部
tip：
	如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
	vector对象的下标运算符可以用于访问已存在的元素而不能够用于添加元素(添加元素请使用push_back)
	
vector支持下标运算符，string支持迭代器
  1 #include <iostream>
  2 #include <string>
  3 #include <cstring>
  4 #include <vector>
  5 using namespace std;
  6 int main()
  7 {
  8     string a = "this is a string";
  9     cout << *a.begin() << endl;       //t
 10 
 11     vector<int> vecint;
 12     for(int i = 0; i < 10; i++)
 13         vecint.push_back(i);
 14     cout << vecint[0] << endl;      //0
 15     return 0;
 16 }

iterator和const_iterator用来表示迭代器的类型
vector<int>:: iterator it;	//it能读写vector<int>的元素
string:: iterator it2;	//it2能读写string对象中的字符
vector<int>:: iterator it3;	//it3只能读元素不能够写元素

vector<int> v;
const vector<int> cv;
auto it1 = v.begin();	//it1的类型为vector<int>:: iterator
auto it2 = cv.begin();	//it2的类型为vector<int>:: const_iterator
C++11标准
引入cbegin()和cend();
auto it3 = v.cbegin();	//it3的类型为vector<int>:: const_iterator
无论vector对象(string对象)是否是const类型其返回值都是const_iterator类型

不能在范围for循环中向vector对象添加元素
任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效
//如果容器是vector或string，
//如果存储空间被重新分配，迭代器、指针、引用都会失效;
//如果存储空间的未重新分配则在插入位置之前的迭代器、指针、引用都有效而插入位置之后的元素的迭代器、指针、引用都会失效)
//对于vector和string来说当我们删除元素的时候尾后迭代器总会失效
详细：P315

vector和string迭代器 能够使用关系运算符进行比较，但两个迭代器必须合法且指向的是同一个容器

size_t、ptrdiff_t定义在cstddef头文件中
size_t类型，size_t类型是一种机器相关的无符号类型，它被设计的足够大以便能够表示内存中任意对象的大小
ptrdiff_t类型，(eg: 两个指针相减的结果类型)，是一种带符号的类型

int a1[] = {0, 1, 2, 3, 4, 5};
int a2[] = a1;	//error 不能使用一个数组来初始化另一个数组
a2 = a1;	//error 不能将一个数组直接赋值另一个数组
auto a3 = a1;	//a3被初始化为一个指针，指向a1首部

C++11标准
int array[] = {0, 1, 2, 3, 4, 5, 6};
int *beg = begin(array);	//指向数组首元素
int *end = end(array);	//指向数组尾元素的下一元素位置

虽然标准库类型string和vector也支持下标运算但是标准库类型限定使用的下标类型必须是无符号类型(eg: size_type)
如果它们的下标设置成了有符号的类型，则会自动转成string::size_type无符号类型(所以当下标为负值的时候很容易出错)

char a[] = {'g', 'a', 'o'};		//不以空字符结束
cout << strlen(a) << endl;	//长度未知，strlen运行到'\0'才会停下来

string可以直接使用<、>等关系运算符比较字符串而C风格必须借助字符串操作函数

cin >> v1 >> v2;	//先读入v1，再读入v2
求值顺序：
int i = f1() * f2();	//无法确定是f1先调用还是f2先调用
<<运算符也没有规定何时以及如何对运算对象求值
eg:
	int i = 1;
	cout　<< i << " " << ++i << endl;	//可能先求++i的值再求i，也有可能先求i再求++i  此表达式的结果不可预知
有四种运算符规定运算对象的求值顺序
(自左向右求值)
逻辑与&&
逻辑或||
条件运算符?:
逗号运算符,

m%(-n) => m%n
(-m)%n => -(m%n)
-21%-8 => -5

强制类型转换(显示类型转换)
1、static_cast:
	只要不包含底层const，都可以使用(const int ci = 42; => 顶层  	const int *pi = &ci; => 底层)
	int i;
	double slope = static_cast<double>(i);
2、dynamic_cast:
3、const_cast:
	只能改变运算对象底层const，不能用const_cast改变表达式的类型
	const char *cp
	static_cast<string>(cp);	//true: 字符串字面值转换成string类型
	const_cast<string>(cp);		//false: const_cast只能改变常量属性
4、reinterpret_cast:
	为运算对象的位模式提供较低层次上的重新解释
	
;	//空语句
ival = v1 + v2;;	//true 第二个;表示一个空语句

for(;;) for循环支持定义多个对象，但是只支持一条声明语句

//范围for语句
for(declaration : expression)
	statement
范围for语句中预存了end值，所以在范围for语句中使用删除、插入操作都有可能使end函数的值无效   P169

使用引用避免拷贝
eg：比较两个string字符串，但是string对象很长的话
bool isShorter(const string &s1, const string &s2)
{
	return s1.size() < s2.size();
}
并且如果函数无须改变引用形参的值，最好将其声明为常量引用;
eg：string::size_type find_char(string &s, char c, string::size_type &occurs);
如果find_char("Hello World", 'o', ctr);调用的话编译会发生错误，因为string &s只能接受非常量string对象，所以应该设为const string &s
9，哦，，哦，\，}
实参初始化形参时会忽略掉顶层const
c++中可以定义若干具有相同名字的函数，但是不同形参列表应该有明显的区别
void fcn(const int i)
void fcn(int i)
//error 重复定义，因为顶层const被忽略掉了

int main(int argc, char *argv[])
使用argv的时候注意argv[0]保存的是程序的名字，用户的输入从argv[1]开始保存

initializer_list类型(保存在同名头文件中)
使用与vector一样，不一样的是initializer_list对象中的元素永远是常量值
eg：
	//expected和actual是string对象
	if(expected != actual)
		error_msg("functionX", expected, actual);
	else
		error_msg("functionX", "okay");
//error_msg函数形参个数不同
void error_msg(ErrCode e, initializer_list<string> i1) {}	//只要类型相同就可以使用initializer_list模板  P199

string retvlaue()
{
	return "Empty";	//error   字面值常量转换成局部临时的string对象，函数结束时存储空间会释放
}

vector<string> process()
{
	//......
	if(...)
		return {};	//返回一个空vector对象
	else
		return {"functionX", "string"};	//返回列表初始化的vector对象
}

返回数组指针
int (*func(int i))[10];		//函数func接受一个int类型实参，返回一个指向含有10个整数的数组的指针
可以使用尾置返回类型简化它
auto func(int i) -> int(*)[10];

重载：
二义性调用：有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时将发生错误

string read()
void print(const string &);
void print(double);
void fooBar(int ival)
{
	bool read = false;	//新作用域：隐藏了外层的read
	string s = read();	//error: read是一个布尔值，而不是函数
	void print(int);	//声明函数，隐藏了之前的print
	print("Value: ");	//error: print(const string &)被隐藏
	print(3.14);		//true: 调用print(int), print(double)被隐藏掉了
}

内联函数inline
在被调用函数的返回类型前面加上关键字inline
inline const string & shorterString(const string &s1, const string &s2)
{
	return s1.size() <= s2.size() ? s1 : s2;
}

cout << shorterString(s1, s2) << endl;
在编译过程中会展开成
cout << (s1.size() <= s2.size() ? s1 : s2) << endl;
的形式从而省去了调用函数产生的开销

//常量表达式
constexpr size_t scale(size_t cnt) {return cnt;}
当scale的实参是常量时，它返回值也是一个常量表达式；反之则不然

assert(exp);	//exp为一个表达式
NDEBUG		//关闭调试状态
CC -D NDEBUG main.c 或者在main.c一开始写#define NDEBUG

//用于调试的局部静态变量
__FILE__	存放文件名的字符串字面值
__LINE__	存放当前行号的整形字面值
__TIME__	存放文件编译时间的字符串字面值
__DATE__	存放文件编译日期的字符串字面值

string screen(int ht = 24, int wid = 80, char backgrnd = ' ');	//默认实参
sring window;
window = screen();	//等价于screen(24, 80, ' ');
window = screen(66, 256, '#');	//screen(66, 256, '#');

//二义性
void f(int, int);
void f(double, double = 3.14);
f(4, 5.6);	//error，两函数同时满足且从整体上来说无法判断孰优孰劣，此调用具有二义性错误

含有多个可行函数时需要满足：
1、该函数每个实参的匹配都不劣于其他可行函数需要的匹配
2、至少有一个实参的匹配优于其他可行函数提供的匹配
如果判断下来没有一个函数脱颖而出则为二义性错误

void manip(long);
void manip(float);
manip(3.14);	//二义性错误，3.14为double类型
//转换等级划分P219

重载函数指针
void ff(int*)
void ff(unsigned int);

void (*pf1)(unsigned int) = ff;	//pf1指向ff(unsigned)
指针类型必须与重载函数中的某一个精确匹配(返回值类型，形参列表)

构造函数eg:
struct Sales_data {
	//构造函数
	Sales_data() = default;		//意义：既需要其他形式的构造函数，也需要默认的构造函数
	Sales_data(const std::string &s) : bookNo(s) {}
	
	std::string bookNo;
}

定义在类内部的成员函数会自动inline

可变数据成员
mutable
eg:
	class Screen {
	public:
		void some_member() const;
	private:
		mutable size_t access_ctr = 0;	//类内初始化c++11
	};
	void Screen::some_member() const	//虽然some_member是const成员函数，但是access_ctr还是可变的
	{
		++access_ctr;	//如果access_ctr没有设置mutable则它是只读的
	}
	
即使两个类的成员列表完全一致，它们也是不同的类型P249

//P250
//前向声明(可以定义指向这种类型的指针或引用，也可以声明(但不能定义)以不完全类型作为参数或者返回类型的函数)
class Y;
class x {
	Y* y = nullptr;	//定义指向Y类型的指针
};
class Y {
	X x;
};

一个类的成员函数作为另一个类的友元		//该成员函数必须在另一个类之前声明！！！		P251
struct X {
	friend void f() {/*友元函数可以定义在类的内部*/};	//即使在类中被定义，只要还没声明那么在类中该函数还是不可见的
	x() {f();}	//error： f还没有被声明
	void g();
}
void f();	//声明f函数
void X::g {return f();}	//true, f()已经被声明

编译器处理完类中的全部声明后才会处理成员函数的定义

typedef double Money;
string bal;
class Account {
public:
	Money balance() {return bal;}	//编译balance的声明时，会先找到Money的声明，balance函数体在整个类可见后才处理，所以返回的是bal成员对象而不是string对象
private:
	Money bal;
	//....
}

构造函数的初始化和赋值
class ConstRef {
public:
	ConstRef (int ii);
private:
	int i;
	const int ci;
	int &ri;
}
//赋值操作
ConstRef::ConstRef(int ii)
{
	i = ii;		//true;
	ci = ii;	//error	const不能赋值
	ri = i;		//error ri没被初始化
}
//列表初始化(显示的初始化引用和const成员)
ConstRef::ConstRef(int ii) : i(ii), ci(ii), ri(i) {}

//委托构造函数
class Sales_data {
public:
	//非委托构造函数
	Sale_data(string a, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt *price) {}
	//以下构造函数全部委托第一条构造函数
	Sales_data() : Sales_data("", 0, 0);
	Sales_data(string s): Sales_data(s, 0, 0);
	
	//....
}

隐式的类类型转换
注意：编译器只会自动执行一步类型转换
combine(const Sale_data &);
combine("9-9999-9999");	//error, 需要把9-9999-9999转换成string类型才能再转换成Sale_data类型需要两步
//true
combine(string("9-9999-9999"));	//隐式转换
combine(Sale_data("9-9999-9999"));	//显示转换

//抑制构造函数的隐式转换
在构造函数前加上explicit关键字(explicit Sale_data(const std::string &s):bookNo(s) {})，之前两种用法都不能通过编译(除了显示转换的方式)。
注意：
1、explicit只对一个实参的构造函数有效，并且需要多个实参的构造函数也不能用于执行隐式类型转换
2、只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应该重复
3、explicit修饰的构造函数只能使用直接初始化的方式
Sale_data item1("hiya");	//直接初始化	true
Sale_data item2 = "hiya";	//拷贝初始化	error

静态成员函数
1、不能包含this指针
2、静态成员函数不能声明成const
3、不能在static函数体内使用this指针
4、静态数据成员一般在类内部声明在类的外部定义和初始化(由于不属于类的任何一个对象，所以它们不是由类的构造函数初始化的)
5、一般静态数据成员不应该在类内部初始化，除了: (在Account类内部)static constexpr int period = 30;	//period是常量表达式   P270
6、即使一个常量静态数据成员在类内部初始化了，通常情况下也应该在类的外部定义(不带初始值)一下该成员
constexpr int Account::period;	//一个不带初始值的静态成员的外部定义

IO库
iostream：用于读写的流基本类型(istream, ostream, iostream)
fstream：读写命名文件类型(ifstream, ofstream, fstream)
sstream: 读写内存string对象类型(istringstream, ostringstream, stringstream)
//不能拷贝或对IO对象赋值 ofstream out1, out2;	out1 = out2;	//error

cout << unitbuf;	//所有输出操作后都会立即刷新缓冲区
cout << nounitbuf;	//回到正常的缓冲方式
!!如果程序崩溃输出缓冲区不会被刷新

文件输入输出
fstream fstrm;	//创建一个未绑定的文件流
fstream fstrm(s);	//创建一个fstream，并打开名为s的文件
fstream fstrm(s, mode);	//创建一个fstream，并按照mode打开文件
fstrm.open(s);	//打开名为s的文件，并将文件与fstrm绑定
fstrm.close();	//关闭文件
fstrm.is_open();	//返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭


文件mode：
in	//读
out	//写		会丢失已有数据(可以同时指定app或in模式保证数据不丢失)
app	//每次写操作前均定位到文件末尾
ate	//打开文件后立即定位到文件末尾
trunc	//截断文件
binary	//以二进制的方式进行IO
open调用默认的模式是out模式(out模式意味着同时使用trunc模式)
限制：P286

istringstream和ostringstream对整行文本的输出输入比较有效果

iostream处理控制台IO
fstream处理命名文件IO
stringstream完成内存string的IO
fstream和stringstream都是继承自iostream

顺序容器
vector: 可变大小数组
deque: 双端对列
list: 双向链表
forward_list: 单向链表	不支持--操作 支持empty和max_size操作但不支持size操作
array: 固定大小数组
string: 与vector类似，但专门用于保存字符
最好使用vector，程序要求随机访问元素，则使用vector或deque，程序要求在容器的中间插入或删除元素，则使用list或forward_list

如果顺序容器中的类型没有默认构造函数就需要提供一个初始值
//noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);	//true   数目：10，初始值：init
vector<noDefault> v2(10);	//false

使用迭代器拷贝不要求容器类型和元素类型相同(前提是元素类型之间可以转换)，直接拷贝就要保证两个容器的类型及其元素类型必须匹配
list<string> authors = {"milton", "shakespeara", "austen"};
it为authors中的一个元素
deque<string> authList(authors.begin(), it);	//拷贝元素直到但不包括it指向的元素

定义一个array时，除了要指定元素类型还需要指定容器大小
array<int, 42> ia1;	//true
array<int> ia2;	//false

内置数组类型不能进行拷贝或对象赋值操作但是array类型可以
int dits[3] = {0, 1, 2};
int cpy[3] = dits;	//false
array<int, 3> digits = {0, 1, 2};
array<int, 3> copy = digits;	//true

顺序容器的赋值
  6 int main() {
  7     vector<int> i1 = {0, 1, 2};
  8     vector<int> i2 = {3, 4};
  9 
 10     i1 = i2;
 11 
 12     for(auto i : i1) cout << i << " ";  //3 4
 13     cout << endl;
 14     return 0;
 15 }
 i1 = i2;	//将i1中的内容替换为i2中的内容，包括其大小
 i1 = {0, 1, 3};	//对i1进行列表赋值
 array类型不支持assign和列表赋值

 seq.assign(b, e);	//将seq中的元素替换为迭代器b和e所表示的范围中的元素，迭代器b和e不能指向seq中的元素
 seq.assign(i1);	//将seq中的元素替换为初始化列表i1中的元素
 seq.assign(n, t);	//将seq中的元素替换为n个值为t的元素
 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，而swap和assign则不会(array和string除外)
 assign: 成员类型相同容器类型可以不同的赋值方法
 
 vector<string> svec1(10);
 vector<string> svec2(24);
 swap(svec1, svec2);	//svec1将有24个string元素，svec2将有10个string元素
 swap不会使迭代器失效，iter在交换前指向svec1[3]，交换后则指向svec2[3]
 
 关系运算符(== >= ...)左右的元素类型和容器类型必须相同
 
 
//顺序容器添加元素操作	p305
 forward_list不支持push_back和emplace_back
 string和vector不支持push_front和emplace_front
 
 //在c的尾部创建一个值为t或由args创建的元素，返回void
 c.push_back(t);
 c.emplace_back(args);
 push_front、emplace_front操作类似
 
 insert	//插入元素
 insert第一个参数为迭代器
 //在迭代器p指向的元素前创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器
 c.insert(p,t);
 c.emplace(p,args);
 
 c.insert(p,n,t);	//在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，n = 0则返回p
 c.insert(p,b,e);	//将迭代器b和e所表示的范围中的元素，插入到p指向的元素之前，b和e不能指向c中的元素
 c.insert(p,i1);	//i1是元素值列表，将这些定制插入到迭代器p指向的元素之前
 
 对vector、string和deque插入元素会使指向容器的迭代器、引用和指针失效
 
 //iter指向c中的一个元素，其中保存了Sales_data元素
 c.emplace_back();	//使用Sales_data的默认构造函数
 c.empalec(iter, "999-999999999");	//使用Sale_data(string)
 //使用Sales_data的接收一个ISBN、一个count和一个price的构造函数
 c.emplace_front("999-987639324", 25, 15.99);
 
 //访问顺序容器中的元素
 at和下标操作只适用于string、vector、deque和array
 back不适用forward_list
 c.back()	//返回c中尾元素的引用，若c为空，函数行为未定义
 c.front()	//返回c中首元素的引用，若c为空，函数行为未定义
 c[n]		//下标访问，越界，函数行为未定义
 c.at(n)	//下标访问，越界，抛出out_of_range异常
 
 //删除元素
 forward_list不支持pop_back; vector和string不支持pop_front
 c.pop_back()	//删除c中的尾元素
 c.pop_front()	//删除c中的首元素
 c.erase(p);	//删除迭代器p所指定的元素，返回一个指向被删除元素之后元素的迭代器
 c.erase(b, e);	//删除迭代器b和e指定范围内的元素[b, e)，返回一个指向最后一个被删元素之后的迭代器
 c.clear();		//删除c中的所有元素
 删除deque中除首尾位置的任何元素都会使所有迭代器、引用和指针失效(如果在首尾位置添加元素迭代器会失效//删除(删除尾元素会使尾后迭代器失效，其他不受影响))。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效
 
 forward_list中插入删除操作
 insert_after、emplace_after、erase_after和before_begin(返回一个首前迭代器)
 before_begin允许我们在链表首元素之前并不存在的元素之后添加或删除元素
 在处理forward_list中添加或删除元素时需要关注两个迭代器：一个指向待处理元素，一个指向其前驱(before_begin)	P313
 
 改变容器大小resize(array不支持)
 //当前大小大于所要求的的大小，容器后部的元素会被删除，如果当前大小小于所要求的大小，会将新元素加到容器后面
 c.resize(n);	//调整c的大小为n个元素，若需要添加元素，对新元素默认初始化
 c.resize(n, t);	//调整c的大小为n个元素，任何新添加的元素都初始化为t
 如果resize为缩小容器的操作，则指向被删除元素的迭代器，指针和引用都会失效
 
 哪些操作会使容器的迭代器、引用和指针失效？P315
 无论是添加或删除元素list和forward_list的(对于删除操作来说：指向其他位置的)迭代器、引用和指针都不会失效
 当添加/删除vector或string的元素，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总会失效，所以添加或删除元素时end必须一直更新
 
 管理容量的成员函数
 capacity:告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素(size指它已经保存的元素数目)
 reserve:操作允许我们通知容器它应该准备保存多少个元素
 c.shrink_to_fit()	//请将capacity()减少为与size相同大小
 c.capacity()	//不重新分配内存空间的话，c可以保存多少元素
 c.reserve(n)	//分配至少能容纳n个元素的空间
 //shrink_to_fit只适用于vector、string和deque
 //capacity和reserve只适用于vector和string
 //reserve并不改变容器中元素的数量，它仅影响vector预先分配都打的内存空间  具体见P318

 //n、len2和pos2都是无符号值
 string s(cp, n);		//s是cp指向的数组中前n个字符的考别
 string s(s2, pos2);	//s是string s2从下标pos2开始的字符的拷贝，pos2越界则构造函数的行为未定义
 string s(s2, pos2, len2);	//s是string s2从下标pos2开始len2字符的拷贝，pos2越界则构造函数的行为未定义，不管len2值为多少至多拷贝s2.size() - pos2个字符
 
 s.substr(pos);			//从string的pos位置开始拷贝，超过则抛出out_of_range
 s.substr(pos, n);		//从string和pos位置开始拷贝n个字符， pos默认值为0，n默认值为s.size()-pos
 
 s.append(args);	//将args追加到s，返回一个指向s的引用
 s.replace(range, args);	//删除s中范围range的字符，替换为args指定的字符，返回一个指向s的引用
 string s("c++ primer"), s2 = s;
 s2.append(" 4th Ed ");	//s2为c++ primer 4th Ed
 s2.replace(11, 3, "5th");	//s2为c++ primer 5th Ed
 s2.replace(11, 3, "fifth");	//s2为c++ primer fifth Ed
 //assign总是替换string中的所有内容，append总是将新字符追加到string末尾
 
 string搜索操作
 //string搜索函数返回string::size_type值，所以使用auto类型保存返回值比较明智
 
 args、s为string
 s.find(args)	//查找s中args第一次出现的位置	//否则返回npos
 s.rfind(args)	//查找s中args最后一次出现的位置
 s.find_first_of(args)	//在s中查找args中任何一个字符第一次出现的位置
 s.find_last_of(args)	//在s中查找args中任何一个字符最后一次出现的位置
 s.find_first_not_of(args)	//在s中查找第一个不在args中的字符
 s.find_last_not_og(args)	//在s中查找最后一个不在args中的字符
 args为以下形式
 c, pos:	从s中位置pos开始查找字符c，pos默认0
 s2, pos:	从s中位置pos开始查找字符串s2，pos默认0
 cp, pos:	从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串pos默认0
 cp, pos, n:从s中位置pos开始查找指针cp指向的数组的前n个字符，pos和n无默认值
 
 string的compare函数P327
 
 数值转换
 to_string(val);	//返回数值val的string表示
 stoi(s,p,b)/stol/stoul/stoll/stoull;	//b表示转换所用的基数默认为10，p是size_t指针，用来保存s中的第一个非数值的字符，默认为0，即函数不保存下标
 stof(s,p)/stod/stold;	//p作用同上
 //如果string不能转换为一个数值则抛出invalid_argument错误
 //如果转换得到的数值无法用任何类型来表示则抛出out_of_range异常
 
 string s2 = "pi = 3.14";
 //转换s2中以数字开始的第一个子串，结果是d = 3.14;
 d = stod(s2.substr(s2.find_first_of("+-.0123456789")));
 
 适配器操作stack、queue和priority_queue	P329
 栈适配器；stack
 队列适配器：queue、priority_queue
 
 泛型算法
 大部分算法定义在algorithm头文件中，numeric也定义了一组数值泛型算法
 
 只读算法：
 find(iter1, iter2, val);	// 查找值
 前两个参数表示元素范围迭代器，第三个参数是值
 它的返回值指向第一个等于给定值得元素的迭代器，若无匹配元素，则返回第二个参数来表示搜索失败
 
 count(iter1, iter2, val);	//计数
 
 accumulate;	//加法，头文件numeric
 三个参数，前两个指出求和的元素范围，第三个参数是和的初值，序列中的元素类型必须与第三个参数匹配，或者能够转换为第三个参数的类型
 int sum = accumulate(vec.cbegin(), vec.cend(), 0);	//对vec中的元素求和，和的初始值为0
 string sum = accumulate(v.cbegin(), v.cend(), string(""));	//true
 string sum = accumulate(v.cbegin(), v.ceng, "");	//error, ""类型为const char*
 
 equal;	//用于确定两个序列是否保存相同的值，返回true/false
 //三个参数，前两个参数表示第一个序列的范围，第三个表示第二个序列的首元素
 //此算法假定第二个序列至少与第一个序列一样长(那些只接受一个单一迭代器来表示的第二序列的算法，都假定第二个序列至少与第一个序列一样长)
 //equal比较roster1的对应位置和roster2是否相等，roster2长度小于roster1的话，返回值永远是false，且roster1的元素会与roster2中不存在的元素比较，产生严重错误
 equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());	//roster2中的数目至少与roster1中一样多
 
 //在下面这个例子中，使用c风格的字符串，equal比较的是其地址而不是
 //字符串数值，所以当地址不同时，即使值相同equal返回false
 22     char a[] = "asdf";
 23     char a1[10]; 
 24     char b1[10]; 
 25     int count1 = 0;
 26     int count2 = 0;
 27     for(auto i : a)
 28     {
 29         a1[count1] = i;
 30         count1++;
 31     }
 32     for(auto i : a)
 33     {
 34         b1[count2] = i;
 35         count2++;
 36     }
 37     cout << equal(begin(a1), end(a1), begin(b1)) << endl;	//0
 
 写入算法(泛型算法不会执行容器操作，它们不会改变容器大小，所以做写入操作的时候要保证容器大小不小于我们的写入元素的数目)
 fill(vec.begin(), vec.end(), 0);	//将每个元素重置为0
 fill(vec.begin(), vec.begin() + vec.size()/2, 10);	//将容器的一个子序列设置为10
 
 fill_n接收一个单迭代器，一个计数值，一个值
 fill_n(vec.begin(), vec.size(), 0);	//将所有元素重置为0
 //fill_n假定写入的元素个数是安全的，所以要确保容器足够大
eg:
 vector<int> vec;	//空向量
 fill_n(vec.begin(), 10, 0);	//error, 结果未定义
 //使用插入迭代器可以防止这种情况的出现，back_inserter(向后插值)，头文件为iterator
 vector<int> vec;
 auto it = back_inserter(vec);
 *it = 42;	//vec现在有一个值为42
 
 vector<int> vec;
 fill_n(back_inserter(vec.begin()), 10, 0);	//true, 添加了十个元素到vec末尾
 
 copy：向目的迭代器指向的输出序列中的元素写入数据
 //传递copy的目的序列至少包含于输入序列一样多的元素，返回是其目的的位置迭代器(递增之后)的地址
 int a1[] = {1, 2, 3, 4};
 int a2[sizeof(a1)/sizeof(*a1)];
 //ret指向拷贝到a2的尾元素之后的位置
 auto ret = copy(begin(a1), end(a1), a2);	//把a1的内容拷贝给a2
 
 //将ilst中所有值为0的元素改为42
 replace(ilst.begin(), ilst.end(), 0, 42);
 //ilst不变，ivec是ilst的拷贝，但所有的0都变为42
 replace(ilst.cbegin(), ilst.end(), back_inserter(ivec), 0, 42);
 
 重排容器算法
 sort使用元素类型的<运算符来实现排序
 unique用来消除重复单词，返回一个指向不重复区域之后位置的迭代器(算法不能执行容器操作，最后还是需要依靠erase完成删除数据的操作)
 
 向算法传递函数
 sort可以接受第三个参数(谓词(一元谓词/二元谓词))
 //比较函数，用来按长度排序单词
 bool isShorter(const string &s1, const string &s2)
 {
	return s1.size() < s2.size();
 }
 //谓词取代了<来比较元素
 sort(words.begin(), words.end(), isShorter);	//按长度由短至长排序words
 
 //按长度重新排序，长度相同的单词维持字典序
 stable_sort(words.begin(), words.end(), isShorter);
 
 find_if算法接受一对迭代器，表示一个范围，它的第三个参数是一个谓词，它返回第一个使谓词返回非0值得元素，如果不存在则返回尾后迭代器
 
 lambda表达式
 [capture list](parameter list) -> return type {function body}
 //lambda必须使用位置返回来指定返回类型
 //lambda可以忽略列表和返回类型，但必须永远包含捕获列表和函数体
 //如果忽略返回类型，lambda根据函数体中的代码推断出返回类型
 //如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回值类型，则返回void
 auto f = [] {return 42};	//忽略括号和参数列表等价于指定一个空参数列表
 cout << f() << endl;	//42
 
 stable_sort(words.begin(), words.end(),
				[](const string &s1, const string &s2)
					{return s1.size() < s2.size()});	//功能同上
					
 //使用谓词来摆脱算法的谓词必须严格接收一个或两个参数
 
 //获取一个迭代器，指向第一个满足size()>=sz的元素
 auto = wc = find_if(words.begin(), words.end(),
				[sz](const string &a)
					{return a.size() >= sz;})
	
 for_each算法	
 //打印长度大于等于给定值的单词(wc为指向上文返回满足size()>=sz的一个元素的迭代器)
 for_each(wc, words.end(),
		[](const string &s) {cout << s << " ";});
 cout << endl;
 
 lambda捕获的值是在lambda创建时拷贝而不是在调用时拷贝
 eg:
 值捕获：
 size_t v1 = 42;
 //将v1拷贝到名为f的可调用对象
 auto f = [v1] {return v1};
 v1 = 0;
 auto j = f();	//j为42；f在创建的时候就拷贝了v1，因此随后对其的修改不会影响到lambda内对应的内容
 
 引用捕获：
 size_t v1= 42；
 auto f = [v1] {return v1};
 v1 = 0;
 auto j = f();	//j为0；f保存的是v1的引用，而非拷贝
 //当以引用方式捕获一个变量的时候，必须保证在lambda执行时变量是存在的
 
 隐式捕获：P352
 &：引用捕获方式
 =：值捕获方式
 //在隐式捕获和显示捕获混合使用的时候，捕获列表中的第一个元素必须是一个&或=，且隐式捕获和显示捕获的方式必须不同
 
 使用mutable可以改变值拷贝的变量
 size_t v1 = 42;
 auto f = [v1] () mutable {return ++v1;};
 v1 = 0;
 auto j = f();	//j为43
 //而引用捕获的变量是否能改变取决于此引用指向的是const类型还是非const类型
 
 //transform对输入序列中的每个元素调用可调用对象，并将结果写到目的位置(第三个参数)
 transform(vi.begin(), vi.end(), vi.begin(),
		[](int i) -> int
		{if (i < 0) return -i; else return i;});
 //此lambda中函数体包含有return之外的任何语句，所以必须指定返回类型(使用尾置返回类型)，否则返回void
 
 bind函数，定义在头文件function中
 接收一个可调用对象，生成一个新的可调用对象来“适应”原对象参数列表
 auto newCallable = bind(callable, arg_list);
 //newCallable是一个可调用对象，arg_list为参数列表对应给定的callable的参数
 //arg_list参数形式为_n：_1表示newCallable的第一个参数，_2为第二个参数
 
 //check_size(const string &s, size_type sz)第一个参数是const string&
 auto check6 = bind(check_size, _1, 6);
 //只有一个_1表示check6只接受一个参数，占位符出现在arg_list的第一个位置，表示check6此参数对应check_size的第一个参数
 string s = "hello";
 bool b1 = check6(s);	//check6(s)会调用check_size(s, 6);
 
 _n都定义在placeholders(头文件functional)的命名空间中
 _1的using声明为：using std::placeholders::_1;
 using namespace std::placeholders;	//placeholders所定义的名字都可使用
 
 auto g = bind(f, a, b, _2, c, _1);
 //g有两个参数，第一个参数绑定到_1, 第二个参数绑定到_2
 //g的两个参数分别作为第三和第五个参数传递给f(g的第一个参数是f的第五个参数)，f的第一第二第四个参数分别绑定到a,b,c上
 g(_1, _2) <==>f(a, b, _2, c, _1);
 
 //头文件与bind相同
 ref函数返回一个可以拷贝的引用	//用来处理ostream类型不能拷贝的问题	P357
 cref函数生成一个保存const引用的类
 
 插入迭代器
 流迭代器：用来遍历关联的流
 反向迭代器：forward_list不支持
 移动迭代器：不是拷贝其中元素，而是移动它们
 
 插入迭代器
 it = t;	//在it指定的当前位置插入值t
 按照迭代器的不同种类分别调用(不改变原迭代器，拷贝到新的容器中)P341
 back_inserter(t)  创建使用push_back
 front_inserter(t) 创建使用push_front
 inserter(t, p)	   创建使用insert
 //t:值，p:迭代器位置
 *it,++it,it++;	//不会对it做任何事情，每个操作都返回it
 
 流迭代器
 istream_iterator<int> in_iter(cin);	//从cin读取int
 istream_iterator<int> eof;	//空的istream_iterator作为尾后迭代器
 vector<int> vec(in_iter, eof);	//迭代器范围构造vec
 
 ostream_iterator<T> out(os, d);	//out将类型为T的值写到输出流os中, 每个值后面都输出一个d
 //第二个参数是可选参数(是一个c风格的字符串)，且必须将ostream_iterator绑定到一个指定的流
 
 eg：
 //将vec中的每个元素写到cout，每个元素后面加一个空格
 ostream_iterator<int> out_iter(cout, " ");
 for(auto e : vec)
	*out_iter++ = e;	//赋值语句将元素写到cout	//* 和 ++ 没有什么实际作用，可以省略，加上方便理解
 cout << endl;
 
 反向迭代器(forward_list不支持)
 递增和递减操作的含义会颠倒过来	
 通过rbegin、rend、crbegin和crend成员函数来获得反向迭代器
 
 eg：
 first,middle,last
 auto rcomma = find(line.crbegin(), line.crend(), ',');	//反向搜索第一个逗号
 cout << string(line.crbegin(), rcomma) << endl;	//输出tsal，因为反向迭代器会反向处理string
 cout << string(rcomma.base(), line.cend()) << endl;	//last, 使用reverse_iterator的base成员函数完成反向转换
 
 顺序容器：
 输入迭代器：==、!=、++、*、->
 输入迭代器：++、*
 前向迭代器：==、!=、++、*、->
 双向迭代器：==、!=、++、--、*、->
 随机放完迭代器：==、!=、<、<=、>、>=、++、--、+、+=、-、-=、-(two iterators)、*、->、iter[n] == *(iter + n)
 
 关联容器
 关键字：
	有序容器：		//其关键字的排列顺序为字典序而不是按照输入顺序排列的
		map			//保存关键字-值对
		set			//只保存关键字的容器
		multimap	//关键字可重复出现的map
		multiset	//关键字可重复出现的set
	无序容器：(上面容器中元素使用哈希函数来组织)
		unordered_map
		unordered_set
		unordered_multimap
		unordered_multiset
 
 //set和multiset定义在set中；map和multimap定义在map中，无序容器定义在unordered_map和unordered_set中
 
 09		map<string, size_t> word_count;	//map中保存每个元素，string是关键字类型，size_t是值类型
 10     string word;
 11     while(cin >> word)
 12         ++word_count[word];
 13     cout << endl;
 14     for(const auto &w : word_count)
 15         cout << w.first << " occurs " << w.second
 16             << ((w.second > 1) ? " times" : " time") << endl;		
 //输入11 11 22 得到  11 occurs 2 times
					  22 occurs 1 time
 //从map中提取一个元素的时候会得到一个pair类型对象，它保存两个名为first和second的数据成员，在map中first保存关键字，second保存对应值
 
 set<string> exclude = {"a", "A" ....};	//
 上面程序添加一个限制
 if(exclude.find(exclude) == exclude.end())	//只统计不在exclude中出现的单词次数
 
 map/set支持列表初始化
 map = {{key, value}, ....};
 //map和set中的关键字必须是唯一的而multimap和multiset没有这个限制
 eg：
 vector<int> ivec = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5};
 set<int> iset(ivec.cbegin(), ivec.end());
 multiset<int> miset(ivec.cbegin(), ivec.cend());
 cout << iset.size() << endl;	//打印出5个元素  //关键字不能重复
 cout << miset.size() << endl;	//打印出10个元素
 
 pair类型(头文件utility)
 pair保存两个数据成员(分别命名成first和second)
 pair<string, string> w = {"11", "22"};
 w.first为11
 w.second为22
 
 make_pair(v1, v2)返回一个用v1和v2初始化的pair,pair的类型由v1和v2的类型推断出来
 两个pair之间可以使用关系运算符进行比较，由成员数据first和second比较得到
 
 关联容器支持的额外类型别名
 key_type		//此容器的关键字类型
 mapped_type	//每个关键字类型，只适用于map
 value_type		//对于set，与key_type相同
				//对于map，为pair<const key_type, mapped_type>
				
 set<string>::value_type v1;	//v1是一个string
 set<string>::key_type v2;		//v2是一个string
 map<string, int>::value_type v3;	//v3是一个pair<const key_type, mapped_type>
 map<string, int>::key_type v4;		//v4是一个string
 map<string, int>::mapped_type v5;	//v5是一个int
 
 map的value_type是一个pair， 关键字成员是const的，其值不能被改变
 set的虽然有两个迭代器iterator和const_iterator但是它们都只能读取不能修改set中的元素
 
 关联容器添加元素的操作
 insert或emplace的操作返回一个pair,其中first是一个迭代器，指向具有给定关键字的元素，second成员是一个bool，如果关键字已经在容器中，则insert什么也不做，且second部分为false
 对于multiset和multimap(相同的关键字可以映射到多个元素)无须返回bool，因为它们允许重复的关键字
 
 删除操作
 c.erase(k);	//从c中删除每个关键字为k的元素，返回删除元素数量(类型为size_type)
 c.erase(p);	//从c中删除迭代器p指定的元素，p必须指向c中一个真实元素且不能等于c.end(),返回一个指向p之后元素的迭代器
 c.erase(b, e);	//从c中删除迭代器b到e所表示范围内的元素，返回e
 
 map和unordered_map支持下标操作，multimap和unordered_multimap不支持下标操作
 
 c[k];	返回关键字为k的元素，如果k不在c中，添加一个关键字为k的元素，并初始化
 c.at(k);	访问关键字为k的元素，若k不在c中则抛出一个out_of_range异常
 
 map<int, string> map1;
 map1[25] = "Alan";		//下标初始化 关键字25对应值为Alan
 
 对map进行下标操作获得一个mapped_type对象，而解引用一个map迭代器得到的是value_type对象
 
 访问元素
 c.find(k);		//返回一个迭代器，指向第一个关键字为k的元素，如果容器中没有则返回一个尾后迭代器
 c.count(k);	//返回迭代器中关键字k的数量
 c.lower_bound(k);	//返回一个迭代器，指向第一个关键字不小于k的元素
 c.upper_bound(k);	//返回一个迭代器，指向第一个关键字大于k的元素
 c.equal_range(k);	//返回一个迭代器pair，表示关键字等于k的元素范围，若k不存在，则pair的两个成员均等于c.end()
					//pair中第一个迭代器指向第一个与关键字匹配的元素，第二一个迭代器指向最后一个匹配元素之后的位置
 //lower_bound和upper_bound不适用于无序容器
 
 对于multimap和multiset来说，它们有多个元素具有给定关键字，则这些关键字在容器中会相邻储存
 
 使用find查找(lower_bound和upper_bound来返回一个迭代器范围来输出) //如果没有关键字匹配lower_bound和upper_bound会返回相等的迭代器-关键字的第一个安全插入点
 //c为multimap类型，k是需要查找的关键字
 auto iter = c.find(k);
 auto cnt = c.count(k);	//返回关键字为k的元素数量
 //循环查找所有关键字为k的元素值
 while(cnt) {
	cout << iter->second << endl;
	++iter;
	--cnt;
 }
 
 使用equal_range查找
 for (auto pos =  equal_range(k); pos.first != pos.second; ++pos.fisrt)
	cout << pos.first->second << endl;	//打印每个元素值
 
 无序容器(哈希函数、桶)	P395
 
 智能指针(头文件memory)
 1、shared_ptr:	允许多个指针指向同一个对象
 weak_ptr(弱引用)指向shared_ptr所管理的对象
 2、unique_ptr:	独占所指向的对象
 
 1、shared_ptr类：
 shared_ptr<string> p1;	//shared_ptr, 可以指向string
 //默认初始化的智能指针中保存着一个空指针
 
 make_shared<T> (args)	//返回一个shared_ptr,指向一个动态分配的类型为T的对象，使用args初始化对象(最安全的分配和使用动态内存)
 shared_ptr<T>p(q)		//p是shared_ptr q的拷贝，会递增q中的计数器，q中的指针必须能转换为T*
 p.unique()				//若p.use_count()为1，返回true,否则返回false
 p.use_count()			//返回与p共享对象的智能指针数量
 
 shared_ptr<string> p4 = make_shared<string>(10, '9');	//p4指向一个值为"9999999999"的string
 shared_ptr<int> p5 = make_shared<int>();	//p5指向一个int(初始化为0)
 
 auto r = make_shared<int>(42);
 r = q5;//给r赋值，令它指向另一个地址
		//递增q5指向的对象的引用指针
		//递减r指向的对象的引用指针
		//r原来指向的对象已没有引用者，会自动释放
 
 shared_ptr会自动释放相关联的内存(eg：动态内存)
 
 new/delete
 int *p1 = new int(1024);	//p1指向的对象值为1024
 
 int *pi = new int;	//pi指向一个动态分配的、未初始化的无名对象
 int *ps = new string;	//初始化为空string
 //动态分配的const的对象必须初始化(类类型其动态对象可以隐式初始化(eg:string)，其他类型对象必须显示初始化)
 const int *p = new const int(1024);
 const string *ps = new string;
 
 接受指针参数的智能指针构造函数时explicit的，必须使用直接初始化的形式
 shared_ptr<int> p1 = new int(1024);	//error
 shared_ptr<int> p2(new int(1024));		//true
 
 1、不使用相同的内置指针初始化(reset)多个智能指针
 2、不delete get()返回的指针
 3、如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了
 3、不使用get()初始化或reset另一个智能指针
 
/*********************   double free ********************/
  5 void process(shared_ptr<int> ptr)
  6 {
  7     cout << ptr.use_count()  << endl;
  8 }
  9 
 10 //!!!!!!!!!!double free
 11 int main()
 12 {
 13     shared_ptr<int> p(new int(42));
 14     cout << p.use_count() << endl;
 15     process(shared_ptr<int>(p.get()));
 16     cout << p.use_count() << endl;
 17     process(shared_ptr<int>(p.get()));
 18     cout << p.use_count() << endl;
 19     return 0;
 20 }
/*********************   double free ********************/

 unique_ptr指针(在某个时刻只能有一个unique_ptr指向一个给定的对象)
 且没有类似make_shared的标准库函数，所以如果要初始化unique_ptr的话必须采用直接初始化的方式
 unique_ptr<int> p1(new int(42));	//直接初始化
 
 由于unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作
 unique_pt<int> p2(p1);	//error
 unique_ptr<int> p3;
 p3 = p1;				//error
 
 //虽然不能拷贝或赋值，但是可以通过release和reset将指针转移
 u.release();	//u放弃对指针的控制权，返回指针，并将u置为空(通常用来被初始化另一个智能指针或给另一个智能指针赋值)
 //释放u指向的对象，如果提供了内置指针q，令u指向这个对象；否则将u置为空
 u.reset();
 u.reset(q);
 u.reset(nullptr);
 
 unique_ptr<int> p(new int(42));
 p.release();				//false: p不会释放内存，而且我们丢失了指针
 auto p1 = p.release();		//true:	必须记得delete(p1);
 
 //不能拷贝和赋值有一个例外就是在unique_ptr即将要被销毁时，例如局部函数返回一个unique_ptr
 
 unique_ptr删除器
 //p指向一个类型为objT的对象，并使用一个类型为delT的对象释放objT对象
 //它会调用一个名为fcn的delT类型对象
 unique_ptr<objT, delT> p (new objT, fcn);
 
 weak_ptr指向由一个shared_ptr管理的对象
 将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数
 
 //weak_ptr需要一个shared_ptr来初始化
 auto p = make_shared<int>(42);
 weak_ptr<int> wp(p);	//wp弱共享p；p的引用计数未改变	//p释放的时候无论weak_ptr有没有指向它，对象都会被释放
 
 weak_ptr不能直接访问对象
 wp.lock();	//用于检查指向的对象是否存在，如果存在则返回一个共享对象的shared_ptr
 
 typedef int arrT[42];	//arrT表示42个int的数组类型
 int *p = new arrT;		//分配一个42个int的数组；p指向第一个int
 
 默认的初始化	
 int *pia = new int[10];	// 10个未初始化的int
 int *pia2 = new int[10]();	//10个值初始化为0的int
 int *pia3 = new int[10]{1, 2, 3, 4, 5};	//列表初始化
 
 char *cp = new char[0];	//true：但cp不能解引用
 
 unique_ptr版本的动态数组
 unique_ptr<int[]> up(new int[10]);	//up指向一个包含10个未初始化int的数组
 up.release();	//自动用delete[]销毁其指针
 //当一个unique_ptr指向一个数组时，我们不能使用点和箭头成员运算符
 up[i];	//返回up拥有的数组中位置i处的对象
 
 shared_ptr不能直接管理动态内存，需要提供一个自定义个删除器(lambda)
 //shared_ptr没有内置下标运算符，所以如果要访问数组中元素，需要使用get()转化为内置指针
 
 new将内存分配和对象构造组合在了一起
 allocator类(头文件memory), 可以将内存分配和对象构造分离开来
 
 allocator<string> alloc;	//可以分配string的allocator对象
 auto const p = alloc.allocate(n);	//分配n个未初始化的string(未构造)
 
 a.deallocate(p, n);	//释放从指针p(类型相同)中地址开始的内存，这块内存保存了n个类型为T的对象，p必须是先前由allocate返回的指针
						//n必须是p创建时所要求的的大小，在使用deallocate前必须对每一个在这个内存中的对象使用destroy
 a.destroy(p);			//对p指向的对象执行析构函数(p为T*类型)
 a.construct(p, args);	//arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象
 
 allocater分配的内存是未构造的，使用construct来构造其中元素
 
 //p指向最后构造的元素之后的位置
 alloc.construct(p++);	//*p为空字符串
 alloc.construct(p++, 10, 'c');	//*p为cccccccccc
 alloc.construct(p++, "hi");	//*p为hi
 
 //不能在未构造的情况下使用原始内存
 cout << *p << endl;	//error
 
 //销毁元素需要调用destroy，且只能对真正构造的元素使用destroy
 
 //使用deallocate释放内存
 
 allocator算法
 uninitialized_copy(b,e,b2)		//从迭代器b和e指出的范围中拷贝元素到b2指定的未构造的原始内存中(b2需要足够大)
 uninitialized_copy_n(b,n,b2);	//拷贝n个元素到b2开始的内存中
 uninitialized_fill(b,e,t);		//迭代器b到e指定的原始内存中创建对象(值均为t的拷贝)
 uninitialized_fill_n(b,n,t);	//创建n个对象(b指向的内存需要足够大)
 
 拷贝控制操作(编译器会自动定义但最好不要这样做)：
 1、拷贝构造函数
 2、拷贝赋值运算符
 3、移动构造函数
 4、移动赋值运算符
 5、析构函数
 
 拷贝构造函数：
 class Foo {
 public:
	Foo();				//默认构造函数
	Foo(const Foo&);	//拷贝构造函数
 }
 //拷贝构造的第一个参数是自身类类型的引用，且任何额外的参数都有默认值。 (一般都使用const且通常不是explicit的)
 
 string dots(10, '.');	//直接初始化
 string s = dots;	//拷贝初始化
 string是一个类，直接初始化调用了类中参数对应的构造函数，而拷贝初始化则调用了类中的拷贝构造函数(类中有移动构造函数的时候，有时会使用移动构造函数而不是拷贝构造函数)
 //在函数调用过程中，具有非引用类型的参数要进行拷贝初始化
 
 //成员类型巨鼎如何拷贝，类类型使用拷贝构造函数拷贝，内置类型则直接拷贝
 拷贝初始化发生时间
 1、使用=定义变量
 2、将一个对象作为实参传递给一个非引用类型的形参
 3、从一个返回类型为非引用类型的函数返回一个对象
 4、用花括号列表初始化一个数组中的元素或一个聚合类中的成员
 
 拷贝赋值运算符
 Sales_data trans, accum;
 trans = accum;	//使用Sales_data的拷贝赋值运算符(如果没有编译器会自己合成)
 
 重载赋值运算符本质是一个函数：operator加上符号
 赋值元素符即为operator=的函数
 //拷贝赋值运算符接受一个与其所在类相同类型的参数
 class Foo {
 public:
	Foo& operator={const Foo&};	//赋值运算符(通常应该返回一个指向其左侧运算对象的引用)
 };
 
 析构函数
 由于其不接受参数，所以它不能被重载
 
 构造函数中，成员的初始化是在函数体执行前
 析构函数中，首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁
 
 //需要析构函数的类通常也需要拷贝和赋值操作(基类除外)
 //需要拷贝构造函数一般也需要拷贝赋值运算符，反之亦然(析构函数则不一定是必须的)
 
 使用=default来显示的要求编译器生成合成的版本P449
 //定义在类内部则合成的函数隐式的声明为内联版本，定义在类外则默认不是内联版本
 
 //阻止拷贝(使用delete 定义删除的函数)
 struct NoCopy {
	NoCopy() = default;	//使用合成的默认构造函数
	NoCopy(const NoCopy&) = delete;	//阻止拷贝
	NoCopy &operator=(const NoCopy&) = delete;	//阻止赋值
	~NoCopy() = default;	//使用合成的析构函数
 }
 = delete用来通知编译器，不希望生成这些成员(=delete可以对任意函数指定，而且必须出现在函数第一次声明的时候)
 //析构函数不能是删除的成员，这会导致无法销毁此类型的对象
 
 //如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数(包括其编译器合成版本)将被定义为删除的
 //对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数
 //如果一个类有const成员，则它不能使用合成的拷贝赋值运算符
 
 类值拷贝赋值运算符
 HasPtr& HasPtr::operator=(const HasPtr &rhs)
 {
	auto newp = new string(*rhs.ps);	//拷贝底层string
	delete ps;	//释放旧内存
	ps = newp;	//从右侧运算对象拷贝数据到本对象
	i = rhs.i;
	return *this;	//返回本对象
 }
 //上面方法中第一第二行调整顺序的话，如果拷贝的是自身，则会发生错误(试图访问已经释放的资源)
 注意点：
 1、如果一个对象赋予它自身，赋值运算符必须能正确工作
 2、大多数赋值运算符组合了析构函数和拷贝构造函数的工作
 
 令一个类展现类似指针的行为的最好方法是使用shared_ptr(或者使用一个引用计数变量(存放指向此内存的指针数量))
 
 //swap函数(交换操作)
 using std::swap;
 swap(a, b);		//这样写编译器会挑选合适的版本(自己写的或标准库版本)(std::swap(a, b)会直接调用标准库版本)
 
 移动构造函数move
 //通常不为move提供一个using声明
 //使用move时，直接使用std::move而不是move
 
 右值引用 &&
 //右值引用只能绑定到一个将要销毁的对象
 //不能将右值引用绑定到一个左值上
 左值引用 &
 //常规引用，不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式
 
 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子
 返回非引用类型的函数，连同算数、关系、位以及后置递增/递减运算符，都生成右值。不能将一个左值引用绑定到这类表达式上，但是可以将一个const的左值引用或一个右值引用绑定到这类表达式上
 
 左值有持久的状态(变量是左值)，而右值要么是字面值常量要么是表达式求值过程中创建的临时对象
 //不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行
 int &&rr1 = 42;	//true, 字面常量是左值
 int &&rr2 = rr1;	//error, 表达式rr1是左值
 
 可以使用std::move将一个左值显示的转换为一个右值引用类型
 int &&rr3 = std::move(rr1);	// ok
 //使用了move后意味着除了对rr1赋值或销毁它外，我们将不再使用它，我们不能对移后源对象的值做任何假设
 
 noexcept 它通知标准库，构造函数不抛出任何异常
 //在一个构造函数中，它一般出现在参数列表和初始化列表开始的冒号之间   P474
 
 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
 移动构造函数的删除情况P476
 //如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的
 
 拷贝构造函数可以代替移动构造函数(一般来说的安全的)，因为拷贝构造函数参数列表是const类型的，它可以接受一个右值
 
 移动迭代器：make_move_iterator 函数接受一个普通迭代器参数，返回一个移动迭代器
 uninitialized_copy(make_move_iterator(b), make_move_iterator(e), b2);	//本来是将迭代器b到e的内容拷贝到b2开始的内存中，现在改为移动
 
 为了维持向后兼容性，我们允许向右值赋值
 string s1 = "asdf" , s2 = "asdf";
 s1 + s2 = "wow";
 
 //在参数列表后放置引用限定符可以限制此种情况
 eg:  Foo &operator=(const Foo&) &;	//只能向可修改的左值赋值
	  Foo sorted() &&;	//可用于可改变的右值
	  Foo sorted() const &;	//可用于任何类型的Foo
 //引用限定符可以是&或&&，分别指出this可以指向一个左值或右值
 //定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符或者所有都不加（const限定则需要不同）
 
 
 //对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数
 int operator+(int, int);	//error不能重定义内置的运算符
 //只能重载已有的运算符，而无权发明新的运算符号，比如operator**就是错误的
 (+、-、*、&)既是一元运算符也是二元运算符
 //有些运算符指定了运算对象的求值顺序，这些求值顺序规则不能运用到重载运算符中，所以一般不重载这些运算符(such as 逻辑与、逻辑或)
 
 IO运算符一般被声明为友元，(假设输入输出运算符是某个类的成员，则它们也必须是ostream、istream的成员，但是这两个类属于标准库，无法添加任何成员)
 输入运算符必须处理输入可能失败的情况，而输出运算符不需要
 算数和关系云算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换
 
 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和==产生的结果一致时才定义<云算符
 可以重载赋值运算符，但不论形参的类型是什么，赋值运算符都必须定义为成员函数(复合赋值运算符通常也应该这样做eg:+= 但不是必须)
 
 下标运算符必须是成员函数(一般定义两个版本，一个返回普通引用，另一个是类的常量成员并且返回常量引用)
 
 递增和递减运算符的类应该同时定义前置版本和后置版本(一般被定义为类的成员)
 StrBlob& operator++();	//前置版本
 StroBlob operator++(int);	//后置版本
 //后置版本中的int形参，唯一的作用就是区分前置版本还是后置版本，而不是参与运算
 //为了与内置版本保持一致，前置运算符应该返回对象的引用而后置运算符应该返回值(递增或递减之前的值) P503
 StrBlob p(a1);
 p.operator++(0);	//调用后置版本  0不可以省略(尽管传入的值会被编译器忽略)
 p.operator++();	//调用前置版本
 
 箭头(->)运算符必须是类的成员，解引用运算符(*)通常也是类的成员(不是必须)
 
 函数调用运算符
 eg:
	struct absInt {
		int operator() (int val) const {
			return val < 0 ? -val : val;
		}
	};
	int i= -42；
	absInt absObj;
	int ui = absObj(i);	//ui => 42
 //函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别
 //如果类定义了调用运算符，则该类的对象称作函数对象，可以作为泛型算法的实参
 //标准库 函数对象 P510
 
 可调用对象和function(functional头文件)	P512
 
 eg：
	不同类型具有相同的调用形式
	//普通函数
	int add(int i, int j) {return i+j;}
	//lambda
	auto mod = [](int i, int j) {return i % j;}
	//函数对象类
	struct divide {
		int operator()(int denominator, int divisor){
			return denominator /divisor;
		}
	}
	//它们共享了一种调用形式int(int, int)	//接受两个int类型，返回一个int类型
	定义一个函数表可以实现共享
	map<string, function<int(int, int)>> binops; 由于第二个参数是函数类型，它们各不相同，所以使用function
	function<int(int, int)>	//他表示接受两个int，返回一个int的可调用对象
	function<int(int, int)> f1 = add;	//函数指针
	function<int(int, int)> f2 = divide;	//函数对象类的对象
	function<int(int, int)> f2 = [](int i, int j)	//lambda
									{return i * j}
	cout << f1(4, 2) << endl;	//6
	cout << f2(4, 2) << endl;	//2
	cout << f2(4, 2) << endl;	//8
	
	//不能将重载函数的名字直接写入function
	int add(int i, int j) {return i + j;}
	Sales_data add(const Sale_data&, const Sales_data&);
	map<string, function<int(int, int)>> binops;
	binops.insert({"+", add});	//error 二义性
	//解决方法
	一：
		int (*fp)(int, int) = add;
		binops.insert({"+", add});
	二：
		binops.insert({"+", [](int a, int b) {return add(a, b);}});
	
 类型转换运算符
 operator type() const;
 //可以面向任意类型(除void)进行定义，不允许转换成数组或者函数类型，但允许转换成指针(包括数组指针，函数指针)和引用类型
 //不能声明返回类型，形参列表必须为空
 //必须定义成类的成员函数
 
 显示类型转换符(避免发生意想不到的错误P516)
 //编译器不会自动执行这一转换
 explicit operator type() const;	//发生类型转换的时候必须显示的转换才能编译通过
 //例外：当作为(1、if，do，while，for的条件部分；2、！，||，&&的运算对象；3、(? :)的条件表达式)的时候还是会发生隐式类型转换
 
 //除了显示地向bool类型转换之外，避免定义类型转换函数
 
 面向对象程序设计(核心思想)：数据抽象、继承和动态绑定(可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象)
 
 对于某些函数来说，基类和派生类希望各自定义合适的版本，这个时候需要将这些函数声明成虚函数(在派生类中可以在这样的函数之前加上virtual或者在其形参列表尾部加上override关键字)
 //当使用基类的引用(或指针)时，该对象可能是基类的对象，也可能是派生类的对象
 //基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此
 //任何构造函数之外的非静态函数都可以是虚函数
 
 private成员：基类和友元可以访问
 protected成员：基类、友元和派生类可以访问(但是派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员)
 eg:
	class Base {
	protected:
		int prot_mem;
	};
	class Sneaky : public Base {
		friend void clobber (Sneaky&);
		friend void clobber (Base&);
		int j;
	};
	void clobber(Sneaky&) {s.j=s.port_mem=0;}	//正确，派生类的成员和友元访问派生类对象类中的基类部分的受保护成员
	void clobber(Base&) {b.prot_mem=0;}			//错误，派生类不能直接访问基类中的受保护成员
 
 //派生类对象中含有与其基类对应的组成部分，所以能够把派生类的对象当成基类来使用(派生类到基类的类型转换)(不存在从基类向派生类的隐式转换(即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换))
 //基类向派生类转换的情况
 1、如果在基类中含有一个或多个虚函数, 可以使用dynamic_cast(P730)请求一个类型转换
 2、如果已知某个基类向派生类的类型转换时安全的就可以使用static_cast(P144)来强制覆盖掉编译器的检查工作
 
 
 //派生类必须使用基类的构造函数来初始化它的基类部分(派生类最好不要直接初始化基类的成员)
 //派生类Bulk_quto  成员：min_qty, discount
 //基类quote   成员 book, p(即bookNo, price)
 Bulk_quote(const string& book, double p, size_t qty, double disc):
			Quote(book, p), min_qty(qty), discount(disc) {};
 //先执行Quote(book, p)基类构造函数，再执行派生类的构造函数
 
 //如果基类定义了一个静态成员，那不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例(P532)
 如果想将某个类作基类，则该类必须已经定义而非仅仅声明(一个类不能派生它本身)
 
 class Base {...};
 class D1: public Base {...};
 class D2: public D1 {...};
 //Base是D1的直接基类，同时是D2的间接基类
 //最终的派生类将包含ta的直接基类的子对象以及每个间接基类的子对象
 
 //在类名的后面跟一个final关键字，可以防止继承的发生
 
 //基类的指针或者引用绑定到派生类对象上
 
 //动态类型和静态类型(当表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致；而基类的指针或引用的静态类型可能与其动态类型不一致)P534
 
 //一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员(P535)
 //当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉
 
 //具有继承关系的多个类型称为多态类型
 
 虚函数规则：
 1、一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须被它覆盖的基类函数完全一致(如果名字相同，形参列表不同，则编译器会认为新定义的这个函数与基类中原有的函数时相互独立的)
 2、虚函数的返回类型也必须与基类函数匹配
 //当类的虚函数返回类型是类本身的指针或引用时，上述规则无效
 //如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致
 
 //使用作用域运算符来强行指定调用虚函数的版本，而不用关心其动态类型到底是什么
 
 //纯虚函数
 在函数体位置(即在声明语句的分号之前)加 =0 就可以将一个纯虚函数说明为纯虚函数
 纯虚函数也可以提供定义，但是函数体必须定义在类的外部而不能在类的内部提供
 
 //含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类
 //不能创建抽象基类的对象
 P542  重构(重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中)(提供统一的接口，通过不同的派生类实现其各自不同的业务功能)oop
 
 //派生访问说明符(公有、私有、受保护)对于派生类的成员(或友元)能否访问其直接基类的成员没什么影响
 //派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)(其对象)对于基类成员的访问权限  P544
 
 如果派生类是私有(受保护)继承基类成员，则基类中的成员对于派生类的派生类来说都是私有的(受保护的)
 
 类D继承自B
 1、只有当D公有地继承B时，用户代码才能使用派生类向基类的转换
 2、不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换
 3、如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换
 
 默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的
 class Base {...};
 struct D1:Base {...};	//public
 class D2:Base {...};	//private
 
 //派生类作用域位于基类作用域之内
 //派生类的成员将隐藏同名的基类成员(可以使用位域运算符来使用隐藏的成员)
 //派生类中的成员函数不会重载基类中的成员函数，派生类中的成员函数的函数名如果和基类中的函数名相同，即使形参列表不同，基类的成员函数也会被隐藏掉
 P549
 
 //基类与派生类中的同名虚函数的形参列表必须相同(否则无法通过基类的引用或指针调用派生类中的虚函数了) P550
 
 //使用类内using 来覆盖基类函数中每一个重载版本。using声明一个名字而不指定形参列表，就可以把该函数中的所有实例添加到派生类的作用域中 P551
 
 //拥有继承关系的基类中需要定义一个虚析构函数(否则delete一个指向派生类对象的基类指针将产生未定义的行为)P552
 //派生类析构函数只负责销毁由派生类自己分配的资源
 
 //一个类只能继承其直接基类的构造函数，类不能继承默认、拷贝和移动构造函数
 //继承构造函数的两种方法P557
 1、使用using
 2、derived(parms) : base(args) {}	//derived是派生类，base是基类，parms和args为形参列表
 //当一个基类构造函数含有默认实参的时候，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参 P558
 
 函数模板
 template <typename T> int compare(const T &v1, const T &v2) //T的类型会在编译的时候由编译器推断而出    P579
 {
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
 }
 
 //模板类型参数
 //类型参数前必须使用关键字class或typename(在参数列表中class和typename没有什么不同)
 template <typename T, class U> calc (const T&, const U&);
 
 //非类型模板参数(一个非类型参数表示一个值而非一个类型) 	P580
 //当非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式
 
 类模板(类似于vector等标准库模板)P584
 类模板的成员函数的名字作用域：	P586
 eg:	template <typename T> ret-type Blob<T>::member-name(param-list);
 //默认情况下，对于一个实例化了的类模板，其成员函数只有在使用时才被实例化P587
 
 在类模板作用域内可以不必指定模板实参，而在作用域外则需要指定P588
 eg:	//BlobPtr  类模板
 作用域内：BlobPtr& operator++();
 作用域外：BlobPtr<T>& operator++();
	
 //另模板自己的类型参数成为友元
 template <typename Type> class Bar {
 friend Type;	//将访问权限授予用来实例化Bar的类型
 };
 类型名Foo、Sales_data
 Foo将成为Bar<Foo>的友元，Sales_data将成为Bar<Sales_data>的友元
 
 //类模板的static成员
 template <typename T> class Foo {
 public:
	static size_t count() {return ctr;}
 private:
	static size_t ctr;
 };
 Foo<int> f1, f2, f3;	//此三个对象共享静态成员(函数)
 
 //模板内不能重用模板参数名    P592
 //使用模板类型参数的类型成员
	template <typename T> typename T::value_type top()....	//P593
 
 //默认模板实参   P594(可以是可调用对象，并且遵循标准库函数的一般规律)
 template <class T = int> class Numbers {....};	//T默认为int
 Numbers<long double> v1;		//使用long double类型代替T类型实例化
 Numbers<> v2;					//使用T默认类型int实例化
 
 //显示实例化减少开销    P598
 
 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换
 (算术转换、派生类向基类的转换以及用户定义的转换都是不允许的)P601
 //如果函数参数类型不是模板参数，则对实参进行正常的类型转换
 
 //函数模板显示实参 P604
 template <typename T1, typename T2, typename T3> T1 sum(T2, T3);	//T2, T3可以由参数列表推断出类型，而T1必须显示指定
 auto val1 = sum<long long> (i, lng);	//T1的类型为long long
 //显示模板实参必须按照从左至右的顺序与对应的模板参数匹配
 template <typename T1, typename T2, typename T3> T3 sum(T1, T2);
 auto val2 = sum<long long> (i, lng);	//error 模板参数不匹配
 auto val3 = sum<long long, int, long> (i, lng);	//true 全部显示指定类型  
 
 //使用尾置返回类型指定函数返回类型
 template <typename It> 
 auto fcn(It beg, It end) -> decltype(*beg) {
	return *beg;		//如果需要返回元素的值而不是引用的时候就需要类型转换模板了
 }
 
 //标准类型转换模板P606
 
 P608
 template <typename T> void f3(T&&);	//可以接受右值，也可以接受左值
 f3(5);		//T推断为int
 int i = 4;	//i为左值
 f3(i);		//T推断为int&
 //对于类型别名或模板参数来说支持引用折叠
 X& &、X& &&和X&& &折叠为X&
 X&& &&折叠为X&&
 
 使用引用参数(无论是左值还是右值)使得const属性得到保持，在引用类型中的const是底层的
 如果一个函数参数是指向模板类型参数的右值引用它对应的const属性和左值/右值属性将得到保持
 
 可变参数模板 P619
 模板参数包：表示零个或多个模板参数
 函数参数包：表示零个或多个函数参数
 template <typename T, typename... Args>
 void foo(const T &t, const Args& .. rest);		//Args模板参数包， rest函数参数包
 
 sizeof...运算符可以计算模板参数或者函数参数的个数
 
 //模板的特例化   P625
 特例化的本质是实例化一个模板，而非重载它，因此特例化不影响函数匹配
 //可以特例化类或者是只特例化类中的某个成员函数 P629
 
 string中下标最小的字符对应bitset中的高位
 
 //随机数操作  P660
 //随机数引擎
 default_random_engine e;	//生成随机无符号随机整数数(生成随机引擎对象)
 //分布式类型引擎(要与上面的引擎对象结合使用(种子))
 uniform_int_distribution<unsigned> u(0, 9);	//设定值范围
 u(e);		//生成0到9之间(包含)的均匀分布的随机数  类型为unsigned (e即为种子值，相同的种子值生成的随机数序列不变)
 uniform_real_distribution<double> f(0, 1);		//设定值范围
 f(e);		//生成0-1之间的double类型的随机数
 
 uniform_int_distribution<> u(0, 9);	//默认int类型
 uniform_real_distribution<double> f(0, 1);		//默认double类型
 
 要使得每次发生的随机数是不同的可以将类型设置为static或者设置随机数发生器种子(seed) P662
 
 bernoulli_distribution类   总是返回一个bool 默认返回true的概率是0.5  不接受模板参数
 bernoulli_distribution b(.55);	//可以调整概率   55/45
 
 IO操作
 //格式化输入输出
 //当操作符改变流的格式状态时，通常改变后的状态对所有后续IO都有效果
 cout << boolalpha;	//后续bool值输出为true/false
 cout << noboolalpha;	//改回默认bool输出0/10
 cout << hex;	cout << oct;	cout << dec;	//分别输出十六进制，八进制，十进制(只对整型值有效)
 cout << showbase;	//显示进制  十六进制0x  八进制0
 cout << noshowbase;	//恢复默认状态
 cout << uppercase << showbase << hex;  //十六进制前的X为大写形式
 cout << nouppercase << noshowbase << dec;
 
 precision和setprecision(头文件iomanip)操纵符用来改变打印精度  p669
 cout << precision(12);	//打印精度为12位
 cout << setprecision(3);	//打印精度为3位
 cout << precision();	//返回当前打印精度
 
 showpoint强制打印小数点  noshowpoint
 scientific科学计数法
 fixed定点十进制
 hexfloat强制浮点数转换为十六进制   defaultfloat恢复默认状态
 
 //输出补白
 setw指定下一个数字或字符串值的最小空间
 left左对齐输出
 right右对齐输出  默认格式
 internal控制负数符号的位置(左对齐符号右对齐值中间填空格)
 setfill允许指定一个字符代替默认的空格来补白输出
 
 

 
 